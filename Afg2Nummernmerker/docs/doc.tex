\documentclass[a4paper,10pt,ngerman]{scrartcl}
\usepackage{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[a4paper,margin=2.5cm,footskip=0.5cm]{geometry}

% Die nächsten drei Felder bitte anpassen:
\newcommand{\Aufgabe}{Aufgabe 2: Nummernmerker} % Aufgabennummer und Aufgabennamen angeben
\newcommand{\TeamID}{00587}       % Team-ID aus dem PMS angeben
\newcommand{\TeamName}{Doge.NET} % Team-Namen angeben
\newcommand{\Namen}{Nikolas Kilian} % Namen der Bearbeiter/-innen dieser Aufgabe angeben

% Fonts
\usepackage{lmodern}
\usepackage{inconsolata}
%\usepackage{courier}

% Kopf- und Fußzeilen
\usepackage{scrlayer-scrpage, lastpage}
\setkomafont{pageheadfoot}{\large\textrm}
\lohead{\Aufgabe}
\rohead{Team-ID: \TeamID}
\cfoot*{\thepage{}/\pageref{LastPage}}

% Position des Titels
\usepackage{titling}
\setlength{\droptitle}{-1.0cm}

% Für mathematische Befehle und Symbole
\usepackage{amsmath}
\usepackage{amssymb}

% Für Bilder
\usepackage{graphicx}

% Für Algorithmen
\usepackage{algpseudocode}

% Für Quelltext
\usepackage{listings}
\usepackage{xcolor}

%\setmonofont{Consolas} %to be used with XeLaTeX or LuaLaTeX
\definecolor{bluekeywords}{rgb}{0,0,1}
\definecolor{greencomments}{rgb}{0,0.5,0}
\definecolor{redstrings}{rgb}{0.64,0.08,0.08}
\definecolor{xmlcomments}{rgb}{0.5,0.5,0.5}
\definecolor{types}{rgb}{0.17,0.57,0.68}
\definecolor{background}{rgb}{0.95,0.95,0.95}

\lstdefinelanguage{CSharp}{ % Better C# highlighting
language=[Sharp]C,
backgroundcolor=\color{background},
captionpos=b,
numbers=left, %Nummerierung
numberstyle=\tiny, % kleine Zeilennummern
frame=lrtb,
showspaces=false,
showtabs=false,
breaklines=true,
showstringspaces=false,
breakatwhitespace=true,
escapeinside={(*@}{@*)},
commentstyle=\color{greencomments},
morekeywords={partial, var, value, get, set},
keywordstyle=\color{bluekeywords},
stringstyle=\color{redstrings},
basicstyle=\ttfamily\small,
literate=%
    {Ö}{{\"O}}1
    {Ä}{{\"A}}1
    {Ü}{{\"U}}1
    {ß}{{\ss}}1
    {ü}{{\"u}}1
    {ä}{{\"a}}1
    {ö}{{\"o}}1
    {~}{{\textasciitilde}}1
}

\lstMakeShortInline[
  language=CSharp,
  columns=fixed,
  basicstyle=\ttfamily
  ,columns=fixed]|

\lstnewenvironment{lstcs}
    {\lstset{
        language=CSharp,
        basicstyle=\ttfamily,
        breaklines=true,
        columns=fullflexible
    }}
{}

% Diese beiden Pakete müssen zuletzt geladen werden
%\usepackage{hyperref} % Anklickbare Links im Dokument
\usepackage{cleveref}

% Daten für die Titelseite
\title{\textbf{\Huge\Aufgabe}}
\author{\LARGE Team-ID: \LARGE \TeamID \\\\
	    \LARGE Team-Name: \LARGE \TeamName \\\\
	    \LARGE Bearbeiter dieser Aufgabe: \\ 
	    \LARGE \Namen\\\\}
\date{\LARGE\today}

\begin{document}

\maketitle
%\tableofcontents

\section{Lösungsidee}

Um die optimale Aufteilung zu ermitteln,
verwenden wir eine Variation des Knapsack-Algorithmus.
Dieser funktioniert wie folgt:

\begin{lstcs}
TeileNummerAuf(nullstellen) {
    if ( <Bereits für gleiche Parameter aufgerufen> ) {
        return <Bereits errechnetes Ergebnis>;
    }
    
    if ( <Zu wenig Stellen zum aufteilen> ) {
    	return <Fehler>;
    }

    for (int i in 2..4) {
        subAufteilung = TeileNummerAuf(nullstellen.Skip(i));

		if ( <subAufteilung Fehler produziert hat> ) continue;
		
        Möglichkeiten.Add([i].Concat(subAufteilung));
    }

    return Möglichkeiten.Max(aufteilung => BewerteAufteilung(nullstellen, aufteilung));
}

BewerteAufteilung(nullstellen, aufteilung) {
    return <Anzahl an führenden Nullstellen in der Aufteilung>;
}
\end{lstcs}

Hierbei werden bereits errechnete Ergebnisse global gespeichert, sodass bei mehreren Rechnungen nacheinander die Ergebnisse der vorigen Durchläufe eventuell bei folgenden Rechnungen wiederverwendet werden können.

\section{Umsetzung}

Für die Umsetzung haben uns für eine Implementierung in C\# 8.0 mit
.NET Core 3.1 entschieden.
Der Sourcecode ähnelt stark dem Pseudocode (siehe Lösungsidee);
die Zentrale Methode die den Algorithmus ausführt hat die Signatur
|NummerMerkingSolution MerkNummern(ArraySegment<bool> zeros, int minSequenceLength = 2, int maxSequenceLength = 4)|.
Hierbei sind min-/maxSequenceLength die Minimal-/Maximallängen
der einzelnen aufgeteilten Segmente.

Für das speicheren alter Ergebnisse wird ein struct |MerkedNummer|
verwendet, welches die Eingaben für die Methode zwischenspeichert,
und ein struct |NummerMerkingSolution|, welches die Ergebnisse
zwischenspeichert. Diese werden in einem
|System.Collections.Generics.Dictionary`2| aufeinander gemappt,
sodass immer einer |MerkedNummer| eine |NummerMerkingSolution|
zugeordnet ist.

Um Rechenzeit zu sparen, wird anders als im Pseudocode kein modifiziertes Array zurückgegeben, sondern eine Instanz des structs \textit{System.ArraySegment`1}. Alle Instanzen dieses structs zeigen beim Ausführen auf das gleiche Array, womit unnötige Array-Allocations verhindert werden, was Kosten des Garbage collectors spart.

\section{Beispiele}

\begin{lstcs}
Starting splitting of number 005480000005179734 with segments of length 2..4
  Digits:             18
Results:
  Leading zeros hit:  2
  Final distribution: 0054 8000 0005 1797

Starting splitting of number 03495929533790154412660 with segments of length 2..4
  Digits:             23
Results:
  Leading zeros hit:  1
  Final distribution: 0349 5929 5337 9015 441 26

Starting splitting of number 5319974879022725607620179 with segments of length 2..4
  Digits:             25
Results:
  Leading zeros hit:  0
  Final distribution: 5319 9748 7902 2725 6076 201

Starting splitting of number 9088761051699482789038331267 with segments of length 2..4
  Digits:             28
Results:
  Leading zeros hit:  0
  Final distribution: 9088 7610 5169 9482 7890 3833 12

Starting splitting of number 011000000011000100111111101011 with segments of length 2..4
  Digits:             30
Results:
  Leading zeros hit:  3
  Final distribution: 0110 0000 001 1000 1001 1111 110 10
\end{lstlisting}

\section{Quellcode}

\begin{lstcs}
private static readonly Dictionary<MerkedNummer, NummerMerkingSolution> MerkedNummers =
    new Dictionary<MerkedNummer, NummerMerkingSolution>();

public static NummerMerkingSolution MerkNummern(ArraySegment<bool> zeros, int minSequenceLength, int maxSequenceLength) =>
    MerkNummern(new MerkedNummer(zeros, minSequenceLength, maxSequenceLength));

private static NummerMerkingSolution MerkNummern(MerkedNummer merkedNummer)
{
    if (MerkedNummers.TryGetValue(merkedNummer, out var optimalDistribution)) return optimalDistribution;

    if (merkedNummer.Zeros.Count < merkedNummer.MinSequenceLength)
    {
        return MerkedNummers[merkedNummer] = NummerMerkingSolution.Failure();
    }

    int nextGenerationSize =
        Math.Min(
            merkedNummer.Zeros.Count,
            merkedNummer.MaxSequenceLength + 1)
        - merkedNummer.MinSequenceLength;

    if (nextGenerationSize <= 0)
    {
        return MerkedNummers[merkedNummer] = NummerMerkingSolution.Empty();
    }

    var nextGeneration = new NummerMerkingSolution[nextGenerationSize];

    for (int i = 0; i < nextGenerationSize; i++)
    {
        int length = i + merkedNummer.MinSequenceLength;

        var subSolution =
            MerkNummern(
                new ArraySegment<bool>(
                  merkedNummer.Zeros.Array,
                  merkedNummer.Zeros.Offset + length,
                  merkedNummer.Zeros.Count - length),
                merkedNummer.MinSequenceLength,
                merkedNummer.MaxSequenceLength);

        nextGeneration[i] = !subSolution.IsSuccessful
            ? NummerMerkingSolution.Failure()
            : NummerMerkingSolution.Success(
                subSolution.Distribution.PrecedeOne(length),
                subSolution.LeadingZerosHit
                + (((IList<bool>)merkedNummer.Zeros)[0] ? 1 : 0));
    }

    var elements = nextGeneration.WhereF(x => x.IsSuccessful);

    if (elements.Length == 0)
    {
        return MerkedNummers[merkedNummer] = NummerMerkingSolution.Failure();
    }

    if (elements.Length == 1)
    {
        return MerkedNummers[merkedNummer] = elements[0];
    }

    NummerMerkingSolution bestSolution = elements.AggregateF((x, y) => x.LeadingZerosHit < y.LeadingZerosHit ? x : y);
    return MerkedNummers[merkedNummer] = bestSolution;
}
\end{lstcs}

\end{document}