\documentclass[a4paper,10pt,ngerman]{scrartcl}
\usepackage{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8x]{inputenc}
\usepackage[a4paper,margin=2.5cm,footskip=0.5cm]{geometry}

% Die nächsten drei Felder bitte anpassen:
\newcommand{\Aufgabe}{Aufgabe 3: Telepaartie} % Aufgabennummer und Aufgabennamen angeben
\newcommand{\TeamID}{00587}       % Team-ID aus dem PMS angeben
\newcommand{\TeamName}{Doge.NET} % Team-Namen angeben
\newcommand{\Namen}{Johannes von Stoephasius \& Nikolas Kilian} % Namen der Bearbeiter/-innen dieser Aufgabe angeben
 
% Fonts
\usepackage{lmodern}
\usepackage{inconsolata}
%\usepackage{courier}

% Kopf- und Fußzeilen
\usepackage{scrlayer-scrpage, lastpage}
\setkomafont{pageheadfoot}{\large\textrm}
\lohead{\Aufgabe}
\rohead{Team-ID: \TeamID}
\cfoot*{\thepage{}/\pageref{LastPage}}

% Position des Titels
\usepackage{titling}
\setlength{\droptitle}{-1.0cm}

% Für mathematische Befehle und Symbole
\usepackage{amsmath}
\usepackage{amssymb}

% Für Bilder
\usepackage{graphicx}

% Für Algorithmen
\usepackage{algpseudocode}

% Für Quelltext
\usepackage{listings}
\usepackage{xcolor}

%\setmonofont{Consolas} %to be used with XeLaTeX or LuaLaTeX
\definecolor{bluekeywords}{rgb}{0,0,1}
\definecolor{greencomments}{rgb}{0,0.5,0}
\definecolor{redstrings}{rgb}{0.64,0.08,0.08}
\definecolor{xmlcomments}{rgb}{0.5,0.5,0.5}
\definecolor{types}{rgb}{0.17,0.57,0.68}
\definecolor{background}{rgb}{0.95,0.95,0.95}

\lstdefinelanguage{CSharp}{ % Better C# highlighting
language=[Sharp]C,
backgroundcolor=\color{background},
captionpos=b,
numbers=left, %Nummerierung
numberstyle=\tiny, % kleine Zeilennummern
frame=lrtb,
showspaces=false,
showtabs=false,
breaklines=true,
showstringspaces=false,
breakatwhitespace=true,
escapeinside={(*@}{@*)},
commentstyle=\color{greencomments},
morekeywords={partial, var, value, get, set},
keywordstyle=\color{bluekeywords},
stringstyle=\color{redstrings},
basicstyle=\ttfamily\small,
literate=%
    {Ö}{{\"O}}1
    {Ä}{{\"A}}1
    {Ü}{{\"U}}1
    {ß}{{\ss}}1
    {ü}{{\"u}}1
    {ä}{{\"a}}1
    {ö}{{\"o}}1
    {~}{{\textasciitilde}}1
}

% Diese beiden Pakete müssen zuletzt geladen werden
\usepackage{hyperref} % Anklickbare Links im Dokument
\usepackage{cleveref}

\lstMakeShortInline[
  language=CSharp,
  columns=fixed,
  basicstyle=\ttfamily
  ,columns=fixed]|

\lstnewenvironment{lstcs}
    {\lstset{
        language=CSharp,
        basicstyle=\ttfamily,
        breaklines=true,
        columns=fullflexible
    }}
{}

% Daten für die Titelseite
\title{\textbf{\Huge\Aufgabe}}
\author{\LARGE Team-ID: \LARGE \TeamID \\\\
	    \LARGE Team-Name: \LARGE \TeamName \\\\
	    \LARGE Bearbeiter dieser Aufgabe: \\ 
	    \LARGE \Namen\\\\}
\date{\LARGE\today}

\begin{document}

\maketitle
\tableofcontents

\vspace{0.5cm}

\section{Lösungsidee}

\subsection{Definitionen}

\paragraph{Zustand} \label{def:state}

Ein Zustand ist definiert als Menge von Behältern, wobei jedem Behälter eine nichtnegative ganze Zahl zugeordnet werden kann, die der Anzahl an Bibern des Gefäßes entspricht.

Weiter können die Behälter untereinander getauscht werden, da die Konstellation die selbe bleibt. Deshalb werden die Biber-Anzahlen eines Zustands immer nur im sortierten Zustand betrachtet, wobei hier aufsteigende Sortierung verwendet wird.

Denotiere man die Menge aller Zustände mit Gesamtbiberzahl \(n\) als \(\mathbb{S}_n\).

\paragraph{Endzustand} \label{def:target}

Ein Endzustand ist jeder Zustand, der genau einen leeren Eimer enthält.

Sind weniger, also keine, leere Eimer enthalten, so ist der Zustand kein Endstand laut der Aufgabenstellung.

Sind mehr enthalten, so ist der Zustand nur durch Operationen auf einen anderen Endzustand zu erhalten, und somit nicht relevant. Zur Errmittlung dieser Endzustände siehe \cref{alg:target}.

Denotiere man die Menge aller Endzustände mit Gesamtbiberzahl \(n\) als \(\mathbb{E}_n\).
Dabei gilt: \(\mathbb{E}_n\subseteq\mathbb{S}_n\)

\paragraph{Ursprungszustand} \label{def:origin}

Ein Ursprungszustand von einem Zustand \(x\), ist jeder Zustand der mit einem einzelnen Telepaartieschritt zum Zustand \(x\) wird.

Die Menge an Ursprungszuständen von \(x\) kann geschrieben werden als \(origin(x)\), mit \(origin : \mathbb{S}_n \to \mathbb{S}_n \).

\paragraph{Generation} \label{def:generation}

Eine Generation ist eine Menge an unterschiedlichen Zuständen.

\subsection{Kernidee}

Die Grundidee der Lösung basiert auf der Idee, nicht alle nicht-Endzustände zu ermitteln und diese optimal zu lösen, sondern invers alle Endzustände zu ermitteln und diese invers auf alle ihre Ursprungszustände zurückzuführen, diese Ursprungszustände wiederrum auf ihre eigenen Ursprungszustände zurückzuführen usw., wobei konstant überprüft wird, ob es nicht ''Abkürzungen'' im Sinne bereits gefundener Zustände gibt.

\subsection{Finden aller Ursprungszustände} \label{alg:origin}

Zum finden der Ursprungszustände \(origin(s)\) eines Zustands \(s \in \mathbb{S}_n\) wird jede Biber-Anzahl mit jeder anderen Biber-Anzahl verglichen. Ist dabei bei einem Vergleich zweier Anzahlen die erste Anzahl größer als 0 und durch 2 teilbar, dann ist es möglich, dass auf diese beiden Behälter eine Telepaartie angewendet wurde. Um diese umzukehren wird die Anzahl im ersten Behälter addiert und die Differenz zum 2. Behälter addiert.
Diese Überprüfung wird für alle Kombinationen zweier Biber-Anzahlen durchgeführt, bis am Ende alle Ursprungszustände gefunden wurden.

\subsubsection{Begründung}

Seien \(a_0, a_1, b_0, b_1 \in \mathbb{N}\) die zwei Biberanzahlen, wobei \(a_0\) und \(b_0\) die Anzahlen vor der Telepaartie repräsentieren, und \(a_1\) und \(b_1\) die danach. Sei weiterhin o.B.d.A. \(a_0 < b_0\).

Laut der Definition der Telepaartie gilt:

\begin{align*}
    a_1 &= 2 a_0 \\
    b_1 &= b_0 - a_0 \\
\end{align*}

Hierraus lässt sich herleiten:

\begin{align*}
    && a_1 &= 2 a_0 \\
    \iff&& a_0 &= \frac{a_1}{2} \\
    && b_1 &= b_0 - a_0 \\
    \iff&& b_1 &= b_0 - \frac{a_1}{2} \\
    \iff&& b_0 &= b_1 + \frac{a_1}{2} \\
    && a_0 &< b_0 \\
    \iff&& \frac{a_1}{2} &< b_1 + \frac{a_1}{2} \\
    \iff&& 0 &< b_1 \\
\end{align*}

Wichtig hierbei ist:

\begin{align*}
    0 &< b_1 \\
    a_0 &= \frac{a_1}{2} \\
    b_0 &= b_1 + \frac{a_1}{2} \\
\end{align*}

\subsection{Generieren der Endzustände} \label{alg:target}

Zur effizienten Findung aller Endzustände werden nicht erst alle möglichen Endzustände mit Duplikaten generiert und am Ende die Duplikate entfernt, sondern gleich nur Zustände berechnet, die nicht wiederholt aufteten werden.

Zur Simplifizierung der Rechnung werden alle Zustände mit Behälterzahl minus eins berechnet, die keine leeren Behälter besitzen. Danach wird an jedes dieser einfach eine null angehängt.

Der Algoritmus funktioniert, indem zuerst für einen Behälter alle möglichen Biberanzahlen ermittelt werden, für die gilt:

\begin{itemize}
    \item Es ist möglich die restlichen Biber so aufzuteilen, dass jeder Behälter genausoviele oder weniger Biber enthält wie der vorherigen
    \item Es ist garantiert, dass die restlichen Behälter alle nicht leer sein müssen 
\end{itemize}

Um zu garantieren, dass die Behälter absteigend befüllbar sind, müssen mindestens \(\lceil\frac{<Anzahl Biber>}{<Anzahl Behälter>}\rceil\) Biber in den ersten Becher.

Um die nicht-Leerheit zu garantieren, müssen maximal \(<Anzahl Biber> - (<Anzahl Becher> + 1)\) Biber in den ersten Becher. Somit kann mindestens ein Biber in jeden restlichen Behälter platziert werden.

Für den trivialen Fall, das nur ein Behälter vorhanden ist, müssen alle Biber in diesen.

Nun lassen sich alle für den ersten Becher mögliche Biberanzahlen bestimmen, und für diese jeweils rekursiv alle folgenden Biberanzahlen. Hierbei ist noch zu beachten, dass noch garantiert werden muss, das die Behälter absteigend voll sind. Dies ist trivialerweise umsetzbar, indem alle Biberanzahlen die größer der Biberanzahlen eines vorherigen Behälters sind eliminiert werden.

\subsection{Hauptalgorithmus}

Sei die Generation \(Gen_{i+1}\) definiert als alle unterschiedliche Ursprungszustände aller Elemente aus \(Gen_i\), die in keiner vorherigen Generation \(Gen_k, k < i\) enthalten sind.

Sei dabei \(Gen_0\) als Spezialfall gleich der Menge aller Endzustände für Gesamtbiberzahl \(n\).

\[Gen_0 := \mathbb{E}_n\]
\[Gen_{i+1} := \left\{ s \mid \left(\exists_{t \in Gen_i} : s \in origin(t)\right) \land \left(\forall_{i_0\in\mathbb{N}, i_0 \leq i}: s \notin Gen_{i_0}\right) \right\}\]

Der Algoritmus funktioniert dann, indem er nach und nach alle nicht-leeren Generationen ermittelt. Sei \(Gen_m\) die letzte nicht-leere Generation, so ist \(LLL(n) = m\).

\subsection{Beweis}

Es existiert eine letzte nicht-leere Generation \(Gen_m\).
Weiterdem gilt \(LLL(n) = m\).

\subsubsection{Hilfssatz 1: Erreichen aller lösbaren Zustände} \label{proof:completeness}

Wähle beliebig aber fest einen Zustand \(s\in\mathbb{S}_n\).
Ist der Zustand lösbar, also durch wiederholte Telepaartie zu einem Endzustand überführbar, so gibt es eine Generation \(Gen_i\) aus \((Gen_i)_{i\in\mathbb{N}}\) mit \(s\in Gen_i\).

\paragraph{Trivialer Fall}
Gilt \(s\in\mathbb{E}_n\), so ist \(s\) lösbar mit 0 Telepaartieschritten. Da \(Gen_0 = \mathbb{E}_n\) gilt, gilt \(s \in Gen_0\).

\paragraph{Beweis durch Widerspruch}

Angenommen \(s \notin Gen_{i}\). Für alle \(i=1,2,...\).

\begin{align*}
    &&s \notin Gen_{i} &\iff \lnot\left(\left(\exists_{t \in Gen_{i-1}} : s \in origin(t)\right) \land \left(\forall_{i_0\in\mathbb{N}, i_0 < i}: s \notin Gen_{i_0}\right)\right) \\
    && &\iff \lnot\left(\exists_{t \in Gen_{i-1}} : s \in origin(t)\right) \lor \lnot\left(\forall_{i_0\in\mathbb{N}, i_0 < i}: s \notin Gen_{i_0}\right) \\
    && &\iff \left(\forall_{t \in Gen_{i-1}} : s \notin origin(t)\right) \lor \left(\exists_{i_0\in\mathbb{N}, i_0 < i}: s \in Gen_{i_0}\right)
\end{align*}

Angenommen es gilt \(\exists_{i_0\in\mathbb{N}, i_0 < i}: s \in Gen_{i_0}\). Wenn dies gilt, existiert ein \(i_0\) für welches gilt: \(s \in Gen_{i_0}\). Somit existiert eine Generation aus \((Gen_i)_{i\in\mathbb{N}}\) mit \(s \in Gen_{i_0}\).

Smot können wir das Problem durch Redefinition \(i := i_0\) also reformulieren als:

\begin{align*}
    &&s \notin Gen_{i} 
    &\iff \forall_{t \in Gen_{i-1}} : s \notin origin(t)
\end{align*}

Dies ist nun zu zeigen:

\begin{align*}
    s \notin Gen_{i}
    &\iff \forall_{t \in Gen_i} : s \notin origin(t) \\
    \intertext{Bemerkung: \(origin(origin(t)) = \left\{ s \mid \exists_{u \in origin(t)} : s \in origin(u) \right\}\)}
    &\iff \forall_{t \in Gen_{i-1}} : s \notin origin(origin(t)) \\
    &\iff \forall_{t \in Gen_{i-1}} : s \notin (origin \circ origin)(t) \\
    &\iff \forall_{t \in Gen_{i-i}} : s \notin (\underbrace{origin \circ ... \circ origin}_{\text{i-mal verkettet}})(t) \\
    &\iff \forall_{t \in \mathbb{E}_n} : s \notin (\underbrace{origin \circ ... \circ origin}_{\text{i-mal verkettet}})(t) \\
\end{align*}

Damit dies gilt, müsste \(s\) für keine Anzahl \(i\) an Telepaartieschritten zu einem Endzustand kommen. Somit müsste \(s\) also unlösbar sein. \(\Box\)

\subsubsection{Korollar aus Hilfssatz 1: Maximale Mindestschrittzahl} \label{proof:maxminsteps}

Wenn \(s \in Gen_i\) gilt, dann ist \(s\) in \(i\) oder weniger Telepaartieschritten zu einem Endzustand überführbar.

\paragraph{Beweis}

Aus \cref{proof:completeness} kann man ablesen, dass damit ein Zustand \(s\in\mathbb{S}_n\) lösbar ist, also ein \(Gen_i\) existiert mit \(s \in Gen_i\), gelten muss:

\begin{align*}
    &&\forall_{t \in Gen_i} : s \notin origin(t) 
    &\iff \forall_{t \in \mathbb{E}_n} : s \notin (\underbrace{origin \circ ... \circ origin}_{\text{i-mal verkettet}})(t) \\ 
    \iff&& \forall_{t \in Gen_i} : s \in origin(t) 
    &\iff \exists_{t \in \mathbb{E}_n} : s \in (\underbrace{origin \circ ... \circ origin}_{\text{i-mal verkettet}})(t) \\ 
\end{align*}

Da laut Definition von \(origin\) die \(i\)-fache Selbstverkettung von \(origin\) alle Zustände sind, von denen aus der Parameter mit weniger als oder genau \(i\) Telepaartieschritten erreicht werden kann ist, ist der Endzustand \(t \in \mathbb{E}_n\) von \(s\) in weniger als oder genau \(i\) Schritten erreichbar. \(\Box\)

\subsubsection{Hilfssatz 2: Eindeutigkeit} \label{proof:uniqueness}

Für jeden lösbaren Zustand \(s \in \mathbb{S}_n\) gilt, dass \textit{genau ein} \(i\) existiert, für dass die Generation \(Gen_i\) mit \(s \in Gen_i\) existiert.

\paragraph{Beweis}

Ist der Zustand \(s\) lösbar, so existiert laut \cref{proof:completeness} ein \(i\) mit \(s \in Gen_i\). Aufgrund der Kondition \(\forall_{i_0\in\mathbb{N}, i_0 < i}: s \notin Gen_{i_0}\) in der Definition von \(Gen_i\) gilt, dass keine Generation \(Gen_j, j < i\) aus \((Gen_i)_{i\in\mathbb{N}}\) existiert, die \(s\) enthält. Andersherum gibt es auch keine späteren Generationen \(Gen_k, k > i\) mit \(s \in Gen_k\), da für diese dann ein \(i_0 = i\) mit \(s \in Gen_{i_0}\) existieren würde, was gegen die Definition von \(Gen_i\) verstößt. \(\Box\)

\subsubsection{Hilfssatz 3: Minimalität der Schritte} \label{proof:minimality}

Für jeden lösbaren Zustand \(s \in \mathbb{S}_n\) mit \(s \in Gen_i\) gilt, dass \(i = LLL(s)\).

\paragraph{Beweis}

Der Fall \(LLL(s) > i\) wird vom Korollar \cref{proof:maxminsteps} wiederlegt.

Somit wäre nur noch zu zeigen das \(LLL(s) < i\) nicht gilt.

Damit \(LLL(s) < i\) gilt, müsste es eine Schrittfolge geben, um \(s\) in einen Endzustand überzuführen, mit \(k < i\) Schritten.

Die Generationen \(Gen_j\) mit \(0 \leq j < i\) enthalten zusammen alle Elemente von allen \(j\)-fachen Selbstverkettungen von \(origin\), also jeden Zustand der in genau \(i-1\) oder weniger Schritten zu einem Endzustand überführbar ist. Mit der Eindeutigkeit der Generationen \cref{proof:uniqueness} verbunden, ist also \(LLL(s) < i\) und \(s \in Gen_j\) äquivalent.

Ist nun \(s \in Gen_i\), gilt laut \cref{proof:uniqueness}, dass \(s\) in keiner anderen Generation aus \((Gen_i)_{i\in\mathbb{N}}\), also auch keiner Generation \(Gen_j\) enthalten ist. Da \(LLL(s) < i \iff s \in Gen_j\) gilt, und da \(s \notin Gen_j\) gilt, gilt auch \(\lnot(LLL(s) < i) \iff LLL(s) \geq i\).

Da \(LLL(s) \geq i\) gilt, gilt \(LLL(s) < i\) nicht. \(\Box\)

\subsubsection{Hilfssatz 4: Garantie der Leerheit} \label{proof:termination}

Die Serie \((Gen_i)_{i\in\mathbb{N}}\) ist bis inklusive zu einem Index \(m\) in keinem Element leer. Nach diesem Index ist sie in jedem Element leer.

\paragraph{Beweis}

Angenommen \(Gen_i = {}\).

\begin{align*}
    Gen_{i+1} :&= \left\{ s \mid \left(\exists_{t \in Gen_i} : s \in origin(t)\right) \land \left(\forall_{i_0\in\mathbb{N}, i_0 \leq i}: s \notin Gen_{i_0}\right) \right\} \\
    & = \{ s \mid (\underbrace{\exists_{t \in \{\}} : s \in origin(t)}_{\substack{\text{In der leeren Menge}\\\text{existieren keine Elemente.}\\\text{Erst Recht keine, die}\\\text{die Kondition erfüllen}}}) \land (\forall_{i_0\in\mathbb{N}, i_0 \leq i}: s \notin Gen_{i_0}) \} \\
    & = \{\} \\
\end{align*}

Somit gilt \(Gen_i = {} \implies Gen_{i+1} = {}\).

Wäre vor einem Index \(m\) eine Generation leer, müssten somit auch folgende Generationen leer sein. Somit wäre \(m\) redefinierbar als der Index wo das erste leere Element vorkommt.

Da nur eine endliche Menge an Zuständen \(s \in \mathbb{S}_n\) existiert, und da alle lösbaren Zustände, welche Teilmenge aller Zustände sind, laut \cref{proof:uniqueness} eindeutig genau einer Generation angehören, ist auch die Menge an nicht-leeren Generationen endlich.

Da endlich viele nicht-leeren Generationen enthalten sein müssen, und da die Serie nicht zwischendrin leere Generationen enthalten kann, muss sie alle nicht-leeren Generationen bis zu einem Index \(m\) haben, und alle leeren ab diesem. \(\Box\)

\subsubsection{Beweis}

Laut \cref{proof:termination} existiert eine letzte, nicht-leere Generation \(Gen_m\).

Da die letzte nicht-leere Menge existiert, ist bekannt, dass alle nicht-leeren Generation einen Index kleiner oder gleich \(m\) haben.

Laut \cref{proof:minimality} gilt für alle \(s \in Gen_i\): \(LLL(s) = i\).

Da alle Generation mit mehr als null Zuständen \(Gen_i\) einen Index \(i \leq m\) haben, ist die maximale \(LLL\) der maximale Index \(m\).

Da die maximale \(LLL\) gleich dem Index \(m\) ist, ist \(L(n) = m\).

\section{Umsetzung}
Zur Umsetzung haben wir den obigen Algorithmus in C\# 8.0 mit
.NET Core 3.0 implementiert.\\
Die Zustände werden in Form einer |public class| State gespeichert.
Die |class| beinhaltet

\begin{enumerate}
    \item |int Iterations| - 
        Eine Funktion zur Errechnung der Itertation des States.
    \item |State? Parent| - 
        Der Vater des State; ist der State ein Endzustand, so ist Parent |null|.
    \item |IReadOnlyList<int> Buckets| - Die Liste an Biberanzahlen.
\end{enumerate}
Die wichtigsten Methoden aus der |class| State sind |public IEnumerable<State> GetNextGen()| und |private State ReverseTeelepartie(int first, int second)|, wobei |GetNextGen()| alle möglichen Zustände findet, auf die Telepaartie angewendet unter anderem der aktuelle Zustand heraus kommen würde und |ReverseTeelepartie(int first, int second)| die gefundenen Zustände berechnet. \\
Die allgemeine Berechnung erfolgt in der |public class| Teelepartie. Hier ist die wichtigste Methode |private static int LLLCore(int numberOfCups, int numberOfItems, State? goal, Action<string>? writeLine)|, die entweder für nur einen gegebenen Fall oder für eine Anzahl von Bibern die Anzahl von nötigen Operationen berechnet.
\section{Beispiele}
Im Folgenden wird das Programm immer mit Argumenten aufgerufen, um den Dialog mit dem CLI zu überspringen. Für mehr Informationen über die möglichen Parameter führen sie den Befehl |Telepaartie.CLI --help| aus.\\
\vspace{0.5cm}
Für die Verteilung 2, 4, 7 ist die Ausgabe:
\begin{lstcs}
./Telepaartie.CLI -l 2,4,7 -v
Starting iteration 2
FERTIG!
Man benötigt 2 Telepaartie-Schritte
Die Berechnung dauerte 0:00 Minuten.
\end{lstcs}
Für die Verteilung 3, 5, 7 ist die Ausgabe:
\begin{lstcs}
./Telepaartie.CLI -l 3,5,7 -v
Starting iteration 3
FERTIG!
Man benötigt 3 Telepaartie-Schritte
Die Berechnung dauerte 0:00 Minuten.
\end{lstcs}
Für die Verteilung 80, 64, 32 ist die Ausgabe:
\begin{lstcs}
./Telepaartie.CLI -l 80,64,32 -v
Starting iteration 2
FERTIG!
Man benötigt 2 Telepaartie-Schritte
Die Berechnung dauerte 0:00 Minuten.
\end{lstcs}
./Telepaartie.CLI -c 3 -e 100 -v
Starting iteration 8

--------------

State (Iter:8) {31;32;37}
State (Iter:7) {5;31;64}
State (Iter:6) {10;31;59}
State (Iter:5) {10;28;62}
State (Iter:4) {20;28;52}
State (Iter:3) {8;40;52}
State (Iter:2) {16;32;52}
State (Iter:1) {32;32;36}
State (Iter:0) {0;36;64}

--------------

State (Iter:8) {5;32;63}
State (Iter:7) {5;31;64}
State (Iter:6) {10;31;59}
State (Iter:5) {10;28;62}
State (Iter:4) {20;28;52}
State (Iter:3) {8;40;52}
State (Iter:2) {16;32;52}
State (Iter:1) {32;32;36}
State (Iter:0) {0;36;64}

--------------


FERTIG!
Man benötigt 8 Telepaartie-Schritte
Die Berechnung dauerte 0:00 Minuten.


\section{Quellcode}

\begin{lstcs}
using System;
using System.Collections.Generic;
using System.Linq;
public static class Teelepartie
    {
        private const string Separator = "--------------";

        public static int L(
            IEnumerable<int> goalBuckets,
            Action<string>? writeLine = null)   //Zum finden der minimalen Anzahl an Operationen für einen Zustand
        {
            if (goalBuckets == null) throw new ArgumentNullException(nameof(goalBuckets));

            var goal = new State(goalBuckets);

            var numberOfCups = goalBuckets.Count();
            var numberOfItems = goalBuckets.Sum();

            return LLLCore(numberOfCups, numberOfItems, goal, writeLine);
        }

        public static int LLL(
            int numberOfCups = 3,
            int numberOfItems = 15,
            Action<string>? writeLine = null)   //Zum finden der maximalen Anzahl der minimalen Anzahlen an Operationen für eine Anzahl
        {
            return LLLCore(numberOfCups, numberOfItems, null, writeLine);
        }

        private static int LLLCore(
            int numberOfCups,
            int numberOfItems,
            State? goal,
            Action<string>? writeLine)
        {
            List<State> lastGen = GetEndingStates(numberOfCups, numberOfItems)  //Alle Endzustände bilden die nullte Generation
                .Select(x => new State(x))
                .ToList();

            List<State> allStates = lastGen
                .ToList();

            for (int i = 0; ; i++)
            {
                writeLine?.Invoke($"\rStarting iteration {i + 1}");

                List<State> nextGen = lastGen
                    .AsParallel()
                    .SelectMany(x => x.GetNextGen())    //Erschaffe aus jedem Element die Kinder
                    .Distinct()                         //Entferne die doppelten Kinder
                    .Except(allStates.AsParallel())     //Entferne die Kinder, die schon in den Alten vorhanden sind
                    .ToList();

                if (goal != null)                               //Falls die Operationsanzahl für nur 1 Zustand festgestellt werden soll
                {
                    if (nextGen.Contains(goal)) return i + 1;   //Wenn das Element in den neuen Kindern vorhanden ist, gebe die Operationsanzahl zurück zurück
                }
                else if (nextGen.Count == 0)                    //Wenn keine neuen Kinder gefunden worden sind
                {
                    writeLine?.Invoke(Environment.NewLine);
                    foreach (var oldestChild in lastGen)        //Ausgabe des Logs, falls erwünscht
                    {
                        writeLine?.Invoke(Environment.NewLine + Separator + Environment.NewLine + Environment.NewLine);

                        for (State? current = oldestChild; current != null; current = current.Parent)
                        {
                            writeLine?.Invoke(current.ToString() + Environment.NewLine);
                        }
                    }

                    writeLine?.Invoke(Environment.NewLine + Separator + Environment.NewLine + Environment.NewLine);

                    return i + 1;               //Gebe die Operationsanzahl zurück
                }

                lastGen = nextGen;               //Die aktuellen Kinder als Väter der nächsten Generation setzen
                allStates.AddRange(nextGen);    //Die aktuellen Kinder der Liste aller Zustände hinzufügen
            }
        }

        private static List<List<int>> GetEndingStates(int NumberOfCups, int NumberOfItems)
        {
            List<List<int>> states = GetStates(NumberOfCups - 1, NumberOfItems);

            foreach (var state in states) state.Insert(0, 0);

            return states;
        }

        private static List<List<int>> GetStates(int numberOfCups, int numberOfItems, int max = -1)
        {
            if (max == -1) max = numberOfItems;
            if (numberOfCups < 1) throw new ArgumentException();
            if (numberOfCups == 1) return new List<List<int>> { new List<int> { numberOfItems } };

            int min = (int)Math.Ceiling(numberOfItems / (decimal)numberOfCups); //Die Anzahl der Elemente, die maximal dem aktuellen Behälter hinzugefügt wird
            return Enumerable.Range(min, Math.Min(max - min + 1, numberOfItems - min))  //Für jede Anzahl zwischen min und dm Rest
                .SelectMany(i =>
                {
                    List<List<int>> states = GetStates(numberOfCups - 1, numberOfItems - i, i); //Finden aller Möglichen Kombinationen für den Rest der Biber und der Behälteranzahl -1
                    foreach (var state in states) state.Add(i);
                    return states;
                })
                .ToList();

            throw new ArgumentException();
        }
    }
\end{lstcs}
\begin{lstcs}
#nullable enable 
    using System;
    using System.Collections.Generic;
    using System.Linq;

    public class State : IEquatable<State>
    {
        public int Iterations => Parent == null ? 0 : (Parent.Iterations + 1);
        public State? Parent { get; }
        public IReadOnlyList<int> Buckets { get; }
        private readonly int _hashCode;

        public State(IEnumerable<int> unsortedBuckets, State? parent = null)
        {
            if (unsortedBuckets.Any(x => x < 0)) throw new ArgumentException(nameof(unsortedBuckets));

            Buckets = unsortedBuckets.OrderBy(x => x).ToList();
            Parent = parent;
            _hashCode = CalculateHashCode();
        }

        private State(List<int> sortedBuckets, State? parent = null)
        {
            Buckets = sortedBuckets;
            Parent = parent;
            _hashCode = CalculateHashCode();
        }

        private State ReverseTeelepartie(int first, int second)
        {
            List<int> temp = new List<int>(Buckets);

            temp[first] /= 2;               //die Anzahl der Biber im ersten Behälter halbieren
            temp[second] += temp[first];    //und die Biber im anderen Behälter hinzufügen
            temp.Sort();

            return new State(temp, this);
        }

        public IEnumerable<State> GetNextGen()
        {
            for (int i = 0; i < Buckets.Count; i++)
            {
                for (int u = 0; u < Buckets.Count; u++) //Finden jeder Kombination
                {
                    if (Buckets[i] % 2 == 0 && Buckets[i] > 0) //Zulässige Werte rausfiltern
                    {
                        yield return ReverseTeelepartie(i, u);  //und die bearbeitete Version zurückgeben
                    }
                }
            }
        }

        private int CalculateHashCode() =>
            Buckets.Aggregate(168560841, (x, y) => (x * -1521134295) + y);

        #region Overrides and Interface Implementations

        public override bool Equals(object? obj) => obj is State state && Equals(state);

        public bool Equals(State state)
        {
            if (state == null) return false;
            if (state.Buckets.Count != Buckets.Count) return false;

            for (int i = 0; i < Buckets.Count; i++)
            {
                if (state.Buckets[i] != Buckets[i]) return false;
            }

            return true;
        }

        public override int GetHashCode() => _hashCode;

        public override string ToString() => "State (Iter:" + Iterations + ") {" + string.Join(';', Buckets) + "}";

        #endregion Overrides and Interface Implementations
    }
\end{lstcs}
\end{document}

