\documentclass[a4paper,10pt,ngerman]{scrartcl}
\usepackage{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8x]{inputenc}
\usepackage[a4paper,margin=2.5cm,footskip=0.5cm]{geometry}

% Die nächsten drei Felder bitte anpassen:
\newcommand{\Aufgabe}{Aufgabe 3: Telepaartie} % Aufgabennummer und Aufgabennamen angeben
\newcommand{\TeamID}{00587}       % Team-ID aus dem PMS angeben
\newcommand{\TeamName}{Doge.NET} % Team-Namen angeben
\newcommand{\Namen}{Johannes von Stoephasius} % Namen der Bearbeiter/-innen dieser Aufgabe angeben
 
% Fonts
\usepackage{lmodern}
\usepackage{inconsolata}
%\usepackage{courier}

% Kopf- und Fußzeilen
\usepackage{scrlayer-scrpage, lastpage}
\setkomafont{pageheadfoot}{\large\textrm}
\lohead{\Aufgabe}
\rohead{Team-ID: \TeamID}
\cfoot*{\thepage{}/\pageref{LastPage}}

% Position des Titels
\usepackage{titling}
\setlength{\droptitle}{-1.0cm}

% Für mathematische Befehle und Symbole
\usepackage{amsmath}
\usepackage{amssymb}

% Für Bilder
\usepackage{graphicx}

% Für Algorithmen
\usepackage{algpseudocode}

% Für Quelltext
\usepackage{listings}
\usepackage{xcolor}

%\setmonofont{Consolas} %to be used with XeLaTeX or LuaLaTeX
\definecolor{bluekeywords}{rgb}{0,0,1}
\definecolor{greencomments}{rgb}{0,0.5,0}
\definecolor{redstrings}{rgb}{0.64,0.08,0.08}
\definecolor{xmlcomments}{rgb}{0.5,0.5,0.5}
\definecolor{types}{rgb}{0.17,0.57,0.68}
\definecolor{background}{rgb}{0.95,0.95,0.95}

\lstdefinelanguage{CSharp}{ % Better C# highlighting
language=[Sharp]C,
backgroundcolor=\color{background},
captionpos=b,
numbers=left, %Nummerierung
numberstyle=\tiny, % kleine Zeilennummern
frame=lrtb,
showspaces=false,
showtabs=false,
breaklines=true,
showstringspaces=false,
breakatwhitespace=true,
escapeinside={(*@}{@*)},
commentstyle=\color{greencomments},
morekeywords={partial, var, value, get, set},
keywordstyle=\color{bluekeywords},
stringstyle=\color{redstrings},
basicstyle=\ttfamily\small,
literate=%
    {Ö}{{\"O}}1
    {Ä}{{\"A}}1
    {Ü}{{\"U}}1
    {ß}{{\ss}}1
    {ü}{{\"u}}1
    {ä}{{\"a}}1
    {ö}{{\"o}}1
    {~}{{\textasciitilde}}1
}

% Diese beiden Pakete müssen zuletzt geladen werden
\usepackage{hyperref} % Anklickbare Links im Dokument
\usepackage{cleveref}

\lstMakeShortInline[
  language=CSharp,
  columns=fixed,
  basicstyle=\ttfamily
  ,columns=fixed]|

\lstnewenvironment{lstcs}
    {\lstset{
        language=CSharp,
        basicstyle=\ttfamily,
        breaklines=true,
        columns=fullflexible
    }}
{}

% Daten für die Titelseite
\title{\textbf{\Huge\Aufgabe}}
\author{\LARGE Team-ID: \LARGE \TeamID \\\\
	    \LARGE Team-Name: \LARGE \TeamName \\\\
	    \LARGE Bearbeiter dieser Aufgabe: \\ 
	    \LARGE \Namen\\\\}
\date{\LARGE\today}

\begin{document}

\maketitle
\tableofcontents

\vspace{0.5cm}

\section{Lösungsidee}

\subsection{Definitionen}

Ein Zustand ist definiert als Menge von Behältern, wobei jedem Behälter eine nichtnegative ganzey Zahl zugeordnet werden kann, die der Anzahl an Bibern des Gefäßes entspricht.

Weiter können die Behälter untereinander getauscht werden, da die Konstellation die selbe bleibt. Deshalb werden die Biber-Anzahlen eines Zustands immer nur im sortierten Zustand betrachtet, wobei hier aufsteigende Sortierung verwendet wird.

\subsection{Kernidee}

Die Grundidee der Lösung basiert auf der Idee, nicht alle Anfangszustände optimal zu lösen, sondern alle Endzustande am suboptimalsten zu mischen.

Das heißt, dass wir einen Baum  aufbauen, wobei die Knoten einzelne Zustände symbolisieren.
Die Kinder eines Knotens werden erzeugt, indem alle Zustände gesucht werden, die in einem Telepaartie Schritt zu diesem umgewandelt werden können. Zur Ermittelung dieser siehe \cref{childGen}.

Der Baum hat nicht wie üblich nur einen Kopf, sondern mehrere. Diese Köpfe stellen die Endzustände dar. Ein Endzustand ist hierbei jeder Zustand, der genau einen leeren Eimer enthält. Sind weniger, also keine, enthalten, so ist der Zustand kein Endstand laut der Aufgabe. Sind mehr enthalten, so ist der Zustand nur durch Operationen auf einem Endzustand zu erhalten, und somit nicht relevant. Zur Errmittlung dieser Endzustände siehe \cref{endingStates}.

%Die Köpfe und damit der Return-Wert des Nebenalgorithmus sind alle Möglichen Verteilungen von Bibern in den Behältern, wobei genau ein Behälter keine Elemente enthält. 
Sind aus \cref{endingStates} die Endzustände errechnet, so kann der Hauptalgorithmus beginnen.
Hierbei werden, mit dem Algorithmus aus \cref{childGen},  alle Zustände gefunden, aus denen der aktuelle Zustand gebildet werden kann, woraus die neue Generation entsteht.
Von den neuen Zuständen werden alle entfernt, die bereits gefunden wurden, sodass keine Dopplungen auftreten können. Auch auf diese neuen Zustände werden alle möglichen Operationen angewendet, wobei dies so lange wiederholt wird, bis keine neuen Zustände gefunden werden. Zu diesem Zeitpunkt wurde der Fall gefunden, der am meisten Schritte braucht, um in einen zulässigen Endzustand überführt zu werden.

\subsection{Finden aller Kinder eines Knotens} \label{childGen}

\subsection{Generieren der Endzustände} \label{endingStates}

\subsection{Hauptalgorithmus}

\section{Umsetzung}

\section{Beispiele}

Genügend Beispiele einbinden! Die Beispiele von der BwInf-Webseite sollten hier diskutiert werden, aber auch eigene Beispiele sind sehr gut – besonders wenn sie Spezialfälle abdecken. Aber bitte nicht 30 Seiten Programmausgabe hier einfügen!

\section{Quellcode}

Unwichtige Teile des Programms sollen hier nicht abgedruckt werden. Dieser Teil sollte nicht mehr als 2–3 Seiten umfassen, maximal 10.

\end{document}

