\documentclass[12pt]{article}

\usepackage{tikz}
\usetikzlibrary{calc}

\newcommand{\cellsize}{0.5}
\newcommand{\circlesize}{0.35}

\newcommand{\printwhitecell}[2][]{\node[draw=gray, semithick, fill=white, minimum width=\cellsize cm, minimum height=\cellsize cm] at #2 {#1};} 
\newcommand{\printblackcell}[1]{\node[draw=gray, semithick, fill=black, minimum width=\cellsize cm, minimum height=\cellsize cm] at #1 {};} 
\newcommand{\printcircle}[1]{\draw[gray, semithick, fill=gray] #1 circle (\circlesize cm/2);} 
\newcommand{\printblackcircle}[1]{\draw[gray, semithick, fill=gray] #1 circle (\circlesize cm/8);} 
\newcommand{\printwhitecircle}[1]{\draw[gray, semithick, fill=gray] #1 circle (\circlesize cm/8);} 

\newcommand{\printcell}[2]{%
    \if#1w%
        \printwhitecell{#2}%
    \else%
        \if#1b%
            \printblackcell{#2}%
        \else%
            \if#1c%
                \printwhitecell{#2}%
                \printcircle{#2}%
            \else%
                \if#1C%
                    \printblackcell{#2}%
                    \printcircle{#2}%
                \else
                    \printwhitecell[#1]{#2}%
                \fi%
            \fi%
        \fi%
    \fi%
}

\newcommand{\printmatrix}[2]{
    \begin{tikzpicture}
    \foreach \line[count=\i] in #2 {
        \foreach \cell[count=\j] in \line {
            \printcell{\cell}{(\j*\cellsize,-\i*\cellsize)}
        }
        \xdef\width{\j}
    }
    \node at ({0.5*(\width+1)*\cellsize}, {(-\i -1)*\cellsize}) {#1};
    \end{tikzpicture}   
}

\begin{document}

\title{Aufgabe 5 - Rominos}

\section{Lösungsidee}

\subsection{Kernidee}

Rominos mit n Blöcken können gefunden werden, in dem zu Rominos mit (n-1) Blöcken ein Block angefügt wird. Hierbei  muss beachtet werden das der Rominostein zusammenhängend bleiben muss, und dass mindestens eine Diagonale bleiben muss.

Um alle möglichen Rominos mit n Blöcken zu finden, muss man also alle Rominos mit (n-1) Blöcken finden, und für diese alle Rominos die durch hinzufügen eines weiteren Blocks enstehen können ermitteln. Dabei wird es Duplikate geben. Eliminiert man diese hat man alle möglichen n-Rominos eindeutig gefunden.

\subsubsection{Beispiel}

Nehme man beispielsweise das 2er-Romino, kann man zum finden aller 3 (= 2 + 1) - Rominos wie folgt Blöcke anfügen:

\printmatrix{}{{
    {c,c,c,w},
    {c,b,w,c},
    {c,w,b,c},
    {w,c,c,c}%
}}

Somit ergeben sich folgende 3-Rominos:

\begin{center}

\begin{minipage}{0.18\textwidth}
\printmatrix{}{{
    {b,w,w,w},
    {w,b,w,w},
    {w,w,b,w},
    {w,w,w,w}%
}}
\end{minipage}
\begin{minipage}{0.18\textwidth}
\printmatrix{}{{
    {w,b,w,w},
    {w,b,w,w},
    {w,w,b,w},
    {w,w,w,w}%
}}
\end{minipage}
\begin{minipage}{0.18\textwidth}
\printmatrix{}{{
    {w,w,b,w},
    {w,b,w,w},
    {w,w,b,w},
    {w,w,w,w}%
}}
\end{minipage}
\begin{minipage}{0.18\textwidth}
\printmatrix{}{{
    {w,w,w,w},
    {b,b,w,w},
    {w,w,b,w},
    {w,w,w,w}%
}}
\end{minipage}
\begin{minipage}{0.18\textwidth}
\printmatrix{}{{
    {w,w,w,w},
    {w,b,w,b},
    {w,w,b,w},
    {w,w,w,w}%
}}
\end{minipage}

\begin{minipage}{0.18\textwidth}
\printmatrix{}{{
    {w,w,w,w},
    {w,b,w,w},
    {b,w,b,w},
    {w,w,w,w}%
}}
\end{minipage}
\begin{minipage}{0.18\textwidth}
\printmatrix{}{{
    {w,w,w,w},
    {w,b,w,w},
    {w,w,b,b},
    {w,w,w,w}%
}}
\end{minipage}
\begin{minipage}{0.18\textwidth}
\printmatrix{}{{
    {w,w,w,w},
    {w,b,w,w},
    {w,w,b,w},
    {w,b,w,w}%
}}
\end{minipage}
\begin{minipage}{0.18\textwidth}
\printmatrix{}{{
    {w,w,w,w},
    {w,b,w,w},
    {w,w,b,w},
    {w,w,b,w}%
}}
\end{minipage}
\begin{minipage}{0.18\textwidth}
\printmatrix{}{{
    {w,w,w,w},
    {w,b,w,w},
    {w,w,b,w},
    {w,w,w,b}%
}}
\end{minipage}

\end{center}

\newpage

Da Rominos mindestens zwei Steine haben müssen um eine Diagonale zu besitzen, ist der Rominostein mit den wenigsten Blöcken eine 2er Diagonale.
\begin{center}
\printmatrix{Kleinster Rominostein}{{
    {b,w},
    {w,b}%
}}
\end{center}

Um alle n-Rominos für ein beliebiges n zu finden, würde man den obigen Algorithmus verwenden um aus dem 2er-Romino alle 3-Rominos zu folgern, dann aus diesen alle 4-Rominos etc. bis man alle n-Rominos errechnet hat.

\subsection{Hinzufügen von Blöcken}

Um Blöcke hinzuzufügen, werden zuerst die Stellen ermittelt, wo Blöcke angefügt werden können, sodass das Romino zusammenhängend bleibt. Hierfür werden die Nachbarn jedes Blocks des Rominos ermittelt, daraufhin werden Duplikate und bereits belegte Blöcke eliminiert.

\subsubsection{Beispiel}

Nehme man beispielsweise wieder das 2er-Romino, würden die Nachbarn aller Blöcke wie folgt ermittelt werden:

\printmatrix{}{{
    {c,c,c,w},
    {c,C,c,w},
    {c,c,C,w},
    {w,w,w,w}%
}}
\printmatrix{}{{
    {c,c,c,w},
    {c,C,c,c},
    {c,c,C,c},
    {w,c,c,c}%
}}

Entfernen bereits existierender Blöcke

\printmatrix{}{{
    {c,c,c,w},
    {c,b,c,c},
    {c,c,b,c},
    {w,c,c,c}%
}}

Es lässt sich hier erkennen, das die Existenz einer echten Diagonale nicht zwingend aufrecht erhalten wird;

\printmatrix{}{{
    {w,w,w,w},
    {w,b,w,w},
    {w,b,b,w},
    {w,w,w,w}%
}}

Um dafür zu sorgen, dass diese echte Diagonale immer existiert, wird eine spezifische Diagonale immer beschützt. 
Bei den Mööglichen Block-additionen beim 2er-Romino beispielsweise würden hierfür die für die Diagonale relevanten Blöcke aus den Block-additionsmöglichkeiten entfernt:

\printmatrix{}{{
    {c,c,c,w},
    {c,b,w,c},
    {c,w,b,c},
    {w,c,c,c}%
}}

Diese 4 beschützten Blöcke werden auch bei Spiegelungen, Verschiebungen und Rotationen mitverfolgt, sodass diese eine Diagonale immer besteht.

\subsection{Eliminierung von Duplikaten}

Zur Eliminierung von Duplikaten werden die Rominos zuerst eindeutig orientiert, um Vergleiche zwischen gleichen, aber transformierten Rominos zu erleichtern.

\subsubsection{Verschiebung}

Die Verschiebung wird eliminiert durch Verschiebung des Rominos in die linke obere Ecke des Gitters; also wird der Block mit der geringsten x-Koordinate auf x=0 verschoben, und der Block mit der geringsten y-Koordinate auf y=0.

\subsubsection{Rotation und Spiegelung}

Um Rotation und Spiegelung eines Rominos zu eliminieren, werden zuerst alle seine Permutationen (also alle Kombinationen von Rotation und Spiegelung) ermittelt, und denen wird ein eindeutiger Wert zugewiesen. Daraufhin wird das Romino mit dem niedrigstem eindeutigem Wert ausgewählt. Die Bestimmung dieses eindeutigen Werts habe ich einen trivialen Algorithmus verwendet wie folgt:

\begin{enumerate}
\item Nehme einen Block b aus der Permutation des Rominos
\item Seien die Koordinaten (x, y) die Koordinaten des Blocks b, wobei die minimale x-Koordinate und die minimale y-Koordinate aus allen Blöcken der Permutation 0 ist.
\item Man weise dem Block b den Wert \(2^{(y * \text{<Anzahl an Blöcken>)} + x}\) zu
\item Addiere die Werte aller Blöcke der Permutation, sei dies der Wert der Permutation
\end{enumerate}

Dabei ist zwar noch viel Raum für Optimierung, aber dieser Algorithmus ist ausreichend und O(n).

\subsubsection{Endgültige Duplikat-Eliminierung}

Zum endgültigen eliminieren der Duplikate, werden zuerst alle Rominos wie oben beschrieben

\subsubsection{Beispiel}


\section{Umsetzung}

Zur Umsetzung habe ich den obigen Algorithmus in C# 8.0 mit .NET Core 3.0 implementiert.

Zur Darstellung von Rominos habe ich ein struct definiert, welches eine Array von den Koordinaten der Blöcke, ein Array von den Koordinaten möglicher Block-Additionen, den eindeutigen Wert, und die linken-oberen Koordinaten der 4 geschützten Positionen der geschützten Diagonale.


%TODO IN CODE: Dont instantiate permutations, make them lazy

\end{document}