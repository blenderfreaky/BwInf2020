\documentclass[12pt]{article}

\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{amsmath}

\usepackage{tikz}
\usetikzlibrary{calc}

\newcommand{\cellsize}{0.5}
\newcommand{\circlesize}{0.35}

\newcommand{\printwhitecell}[2][]{\node[draw=gray, semithick, fill=white, minimum width=\cellsize cm, minimum height=\cellsize cm] at #2 {#1};} 
\newcommand{\printblackcell}[1]{\node[draw=gray, semithick, fill=black, minimum width=\cellsize cm, minimum height=\cellsize cm] at #1 {};} 
\newcommand{\printcircle}[1]{\draw[gray, semithick, fill=gray] #1 circle (\circlesize cm/2);} 
\newcommand{\printblackcircle}[1]{\draw[black, semithick, fill=black] #1 circle (\circlesize cm/8);} 
\newcommand{\printwhitecircle}[1]{\draw[white, semithick, fill=white] #1 circle (\circlesize cm/8);}
%\newcommand{\printdots}[1]{\draw[gray, semithick, fill=gray] #1 circle (\circlesize cm/4);} 

\newcommand{\printcell}[2]{%1
    \if#1w%
        \printwhitecell{#2}%
    \else%
        \if#1b%
            \printblackcell{#2}%
        \else%
            \if#1c%
                \printwhitecell{#2}%
                \printcircle{#2}%
            \else%
                \if#1C%
                    \printblackcell{#2}%
                    \printwhitecircle{#2}%
                \else
                	\if#1d%
                    \printwhitecell{#2}%
                    \printblackcircle{#2}%
                    \else%
                    \printwhitecell[#1]{#2}%
                    \fi%
                \fi%
            \fi%
        \fi%
    \fi%
}

\newcommand{\printmatrix}[2]{
    \begin{tikzpicture}
    \foreach \line[count=\i] in #2 {
        \foreach \cell[count=\j] in \line {
            \printcell{\cell}{(\j*\cellsize,-\i*\cellsize)}
        }
        \xdef\width{\j}
    }
    \node at ({0.5*(\width+1)*\cellsize}, {(-\i -1)*\cellsize}) {#1};
    \end{tikzpicture}   
}

\begin{document}

\title{Aufgabe 5 - Rominos}

\section{Lösungsidee}

\subsection{Kernidee}

Rominos mitt n Blöcken können gefunden werden, in dem zu Rominos mit (n-1) Blöcken ein Block angefügt wird. Hierbei  muss beachtet werden das der Rominostein zusammenhängend bleiben muss, und dass mindestens eine Diagonale bleiben muss.

Um alle möglichen Rominos mit n Blöcken zu finden, muss man also alle Rominos mit (n-1) Blöcken finden, und für diese alle Rominos die durch hinzufügen eines weiteren Blocks enstehen können ermitteln. Dabei wird es Duplikate geben. Eliminiert man diese hat man alle möglichen n-Rominos eindeutig gefunden.

\subsubsection{Beispiel}

Nehme man beispielsweise das 2er-Romino, kann man zum finden aller 3 (= 2 + 1) - Rominos wie folgt Blöcke anfügen:

\printmatrix{}{{
    {c,c,c,w},
    {c,b,w,c},
    {c,w,b,c},
    {w,c,c,c}%
}}

Somit ergeben sich folgende 3-Rominos:

\begin{center}

\begin{minipage}{0.18\textwidth}
\printmatrix{}{{
    {b,w,w,w},
    {w,b,w,w},
    {w,w,b,w},
    {w,w,w,w}%
}}
\end{minipage}
\begin{minipage}{0.18\textwidth}
\printmatrix{}{{
    {w,b,w,w},
    {w,b,w,w},
    {w,w,b,w},
    {w,w,w,w}%
}}
\end{minipage}
\begin{minipage}{0.18\textwidth}
\printmatrix{}{{
    {w,w,b,w},
    {w,b,w,w},
    {w,w,b,w},
    {w,w,w,w}%
}}
\end{minipage}
\begin{minipage}{0.18\textwidth}
\printmatrix{}{{
    {w,w,w,w},
    {b,b,w,w},
    {w,w,b,w},
    {w,w,w,w}%
}}
\end{minipage}
\begin{minipage}{0.18\textwidth}
\printmatrix{}{{
    {w,w,w,w},
    {w,b,w,b},
    {w,w,b,w},
    {w,w,w,w}%
}}
\end{minipage}

\begin{minipage}{0.18\textwidth}
\printmatrix{}{{
    {w,w,w,w},
    {w,b,w,w},
    {b,w,b,w},
    {w,w,w,w}%
}}
\end{minipage}
\begin{minipage}{0.18\textwidth}
\printmatrix{}{{
    {w,w,w,w},
    {w,b,w,w},
    {w,w,b,b},
    {w,w,w,w}%
}}
\end{minipage}
\begin{minipage}{0.18\textwidth}
\printmatrix{}{{
    {w,w,w,w},
    {w,b,w,w},
    {w,w,b,w},
    {w,b,w,w}%
}}
\end{minipage}
\begin{minipage}{0.18\textwidth}
\printmatrix{}{{
    {w,w,w,w},
    {w,b,w,w},
    {w,w,b,w},
    {w,w,b,w}%
}}
\end{minipage}
\begin{minipage}{0.18\textwidth}
\printmatrix{}{{
    {w,w,w,w},
    {w,b,w,w},
    {w,w,b,w},
    {w,w,w,b}%
}}
\end{minipage}

\end{center}

\newpage

Da Rominos mindestens zwei Steine haben müssen um eine Diagonale zu besitzen, ist der Rominostein mit den wenigsten Blöcken eine 2er Diagonale.
\begin{center}
\printmatrix{Kleinster Rominostein}{{
    {b,w},
    {w,b}%
}}
\end{center}

Um alle n-Rominos für ein beliebiges n zu finden, würde man den obigen Algorithmus verwenden um aus dem 2er-Romino alle 3-Rominos zu folgern, dann aus diesen alle 4-Rominos etc. bis man alle n-Rominos errechnet hat.

\subsection{Hinzufügen von Blöcken} \label{addBlocks}

Um Blöcke hinzuzufügen, werden zuerst die Stellen ermittelt, wo Blöcke angefügt werden können, sodass das Romino zusammenhängend bleibt. Hierfür werden die Nachbarn jedes Blocks des Rominos ermittelt, daraufhin werden Duplikate und bereits belegte Blöcke eliminiert.

\subsubsection{Beispiel}

Nehme man beispielsweise wieder das 2er-Romino, würden die Nachbarn aller Blöcke wie folgt ermittelt werden:

\printmatrix{}{{
    {c,c,c,w},
    {c,C,c,w},
    {c,c,C,w},
    {w,w,w,w}%
}}
\printmatrix{}{{
    {c,c,c,w},
    {c,C,c,c},
    {c,c,C,c},
    {w,c,c,c}%
}}

Entfernen bereits existierender Blöcke

\printmatrix{}{{
    {c,c,c,w},
    {c,b,c,c},
    {c,c,b,c},
    {w,c,c,c}%
}}

Es lässt sich hier erkennen, das die Existenz einer echten Diagonale nicht zwingend aufrecht erhalten wird;

\printmatrix{}{{
    {w,w,w,w},
    {w,b,w,w},
    {w,b,b,w},
    {w,w,w,w}%
}}

Um dafür zu sorgen, dass diese echte Diagonale immer existiert, wird eine spezifische Diagonale immer beschützt. 
Bei den Möglichen Block-Additionen beim 2er-Romino beispielsweise würden hierfür die für die Diagonale relevanten Blöcke aus den Block-Additionsmöglichkeiten entfernt:

\printmatrix{}{{
    {c,c,c,w},
    {c,C,d,c},
    {c,d,C,c},
    {w,c,c,c}%
}}

Diese 4 beschützten Blöcke werden auch bei Spiegelungen, Verschiebungen und Rotationen mitverfolgt, sodass diese eine Diagonale immer besteht.

\subsection{Eliminierung von Duplikaten} \label{dupl}

Zur Eliminierung von Duplikaten werden die Rominos zuerst eindeutig orientiert, um Vergleiche zwischen gleichen, aber transformierten Rominos zu erleichtern.

\subsubsection{Verschiebung}

Die Verschiebung wird eliminiert durch Verschiebung des Rominos in die linke obere Ecke des Gitters; also wird der Block mit der geringsten x-Koordinate auf x=0 verschoben, und der Block mit der geringsten y-Koordinate auf y=0.

\subsubsection{Rotation und Spiegelung} \label{uniqueCode}

Um Rotation und Spiegelung eines Rominos zu eliminieren,
werden zuerst alle seine Permutationen
(also alle Kombinationen von Rotation und Spiegelung)
ermittelt, und denen wird ein eindeutiger Wert zugewiesen.
Daraufhin wird das Romino mit dem höchsten dieser eindeutigen Werte ausgewählt.
Hierbei ist es eigentlich egal, ob der niedrigste oder höchste Wert genommen
wird, solange das Ergebnis eindeutig ist.

Die Bestimmung dieses eindeutigen Werts haben wir einen trivialen Algorithmus
verwendet wie folgt:

\begin{enumerate}
\item Nehme einen Block b aus der Permutation des Rominos
\item Seien die Koordinaten (x, y) die Koordinaten des Blocks b, wobei die minimale x-Koordinate und die minimale y-Koordinate aus allen Blöcken der Permutation 0 ist.
\item Man weise dem Block b den Wert \(2^{(y * <\text{Anzahl an Blöcken}>) + x}\) zu
\item Addiere die Werte aller Blöcke der Permutation, sei dies der Wert der Permutation
\end{enumerate}

Dabei ist zwar noch viel Raum für Optimierung,
aber dieser Algorithmus ist ausreichend und O(n).

\subsubsection{Endgültige Duplikat-Eliminierung}

Zum endgültigen eliminieren der Duplikate werden zuerst alle Rominos
wie oben beschrieben orientiert, dann werden die eindeutigen Werte dieser
verglichen, um schnell Gleichheit zu ermitteln. Durch Verwendung dieser
Vergleichsmethode lassen sich schnell Duplikate entfernen.

\newpage

\subsubsection{Beispiel}

\paragraph{Ausgangsromino}

\printmatrix{}{{
    {c,c,c,w},
    {c,C,d,c},
    {c,d,C,c},
    {w,c,c,c}%
}}

\paragraph{Nächste Rominos}

\begin{center}

    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {b,w,w,w},
        {w,b,w,w},
        {w,w,b,w},
        {w,w,w,w}%
    }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {w,b,w,w},
        {w,b,w,w},
        {w,w,b,w},
        {w,w,w,w}%
    }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {w,w,b,w},
        {w,b,w,w},
        {w,w,b,w},
        {w,w,w,w}%
    }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {w,w,w,w},
        {b,b,w,w},
        {w,w,b,w},
        {w,w,w,w}%
    }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {w,w,w,w},
        {w,b,w,b},
        {w,w,b,w},
        {w,w,w,w}%
    }}
    \end{minipage}
    
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {w,w,w,w},
        {w,b,w,w},
        {b,w,b,w},
        {w,w,w,w}%
    }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {w,w,w,w},
        {w,b,w,w},
        {w,w,b,b},
        {w,w,w,w}%
    }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {w,w,w,w},
        {w,b,w,w},
        {w,w,b,w},
        {w,b,w,w}%
    }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {w,w,w,w},
        {w,b,w,w},
        {w,w,b,w},
        {w,w,b,w}%
    }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {w,w,w,w},
        {w,b,w,w},
        {w,w,b,w},
        {w,w,w,b}%
    }}
    \end{minipage}

\end{center}

\paragraph{Verschiebung eliminieren}

\begin{center}

    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {b,w,w,w},
        {w,b,w,w},
        {w,w,b,w},
        {w,w,w,w}%
    }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {b,w,w,w},
        {b,w,w,w},
        {w,b,w,w},
        {w,w,w,w}%
    }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {w,b,w,w},
        {b,w,w,w},
        {w,b,w,w},
        {w,w,w,w}%
    }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {w,w,w,w},
        {b,b,w,w},
        {w,w,b,w},
        {w,w,w,w}%
    }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {w,w,w,w},
        {b,w,b,w},
        {w,b,w,w},
        {w,w,w,w}%
    }}
    \end{minipage}
    
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {w,b,w,w},
        {b,w,b,w},
        {w,w,w,w},
        {w,w,w,w}%
    }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {b,w,w,w},
        {w,b,b,w},
        {w,w,w,w},
        {w,w,w,w}%
    }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {b,w,w,w},
        {w,b,w,w},
        {b,w,w,w},
        {w,w,w,w}%
    }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {b,w,w,w},
        {w,b,w,w},
        {w,b,w,w},
        {w,w,w,w}%
    }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {b,w,w,w},
        {w,b,w,w},
        {w,w,b,w},
        {w,w,w,w}%
    }}
    \end{minipage}

\end{center}

\paragraph{Rotation und Spiegelung eliminieren}


Ausgehend von dem Romino;

\begin{center}

    \printmatrix{}{{
        {b,w,w},
        {w,b,w},
        {w,w,b}%
    }}

\end{center}

werden folgende Permutationen festgestellt:

\begin{center}

    \begin{minipage}{0.4\textwidth}
        \center
        \printmatrix{Permutation 1}{{
            {b,w,w},
            {w,b,w},
            {w,w,b}%
        }}
        \vspace{-0.2cm}
        \[Wert_1 = 2^0 + 2^4 + 2^8 = 273\]
    \end{minipage}
    \begin{minipage}{0.4\textwidth}
        \center
        \printmatrix{Permutation 2}{{
            {w,w,b},
            {w,b,w},
            {b,w,w}%
        }}
        \vspace{-0.2cm}
        \[Wert_2 = 2^2 + 2^4 + 2^6 = 84\]
    \end{minipage}

\end{center}

Hierbei ist \(Wert_2 = 84 < 273 = Wert_1\). Da Permutation 1 mit \(Wert_1\)
den höchsten Wert hat, wird Permutation 1 als die eindeutige Rotierung
festgelegt.

Analog auf alle Rominos angewendet ergibt sich:

\begin{center}

    \begin{minipage}{0.18\textwidth}
        \printmatrix{273}{{
            {b,w,w,w},
            {w,b,w,w},
            {w,w,b,w},
            {w,w,w,w}%
        }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
        \printmatrix{49}{{
            {b,w,w,w},
            {w,b,b,w},
            {w,w,w,w},
            {w,w,w,w}%
        }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
        \printmatrix{42}{{
            {w,b,w,w},
            {b,w,b,w},
            {w,w,w,w},
            {w,w,w,w}%
        }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
        \printmatrix{49}{{
            {b,w,w,w},
            {w,b,b,w},
            {w,w,w,w},
            {w,w,w,w}%
        }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
        \printmatrix{42}{{
            {w,b,w,w},
            {b,w,b,w},
            {w,w,w,w},
            {w,w,w,w}%
        }}
    \end{minipage}
    
    \begin{minipage}{0.18\textwidth}
        \printmatrix{42}{{
            {w,b,w,w},
            {b,w,b,w},
            {w,w,w,w},
            {w,w,w,w}%
        }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
        \printmatrix{49}{{
            {b,w,w,w},
            {w,b,b,w},
            {w,w,w,w},
            {w,w,w,w}%
        }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
        \printmatrix{42}{{
            {w,b,w,w},
            {b,w,b,w},
            {w,w,w,w},
            {w,w,w,w}%
        }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
        \printmatrix{49}{{
            {b,w,w,w},
            {w,b,b,w},
            {w,w,w,w},
            {w,w,w,w}%
        }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
        \printmatrix{273}{{
            {b,w,w,w},
            {w,b,w,w},
            {w,w,b,w},
            {w,w,w,w}%
        }}
    \end{minipage}

\end{center}

Nun lassen sich trivialerweise die Duplikate eliminieren;

\begin{center}

    \begin{minipage}{0.18\textwidth}
        \printmatrix{273}{{
            {b,w,w,w},
            {w,b,w,w},
            {w,w,b,w},
            {w,w,w,w}%
        }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
        \printmatrix{49}{{
            {b,w,w,w},
            {w,b,b,w},
            {w,w,w,w},
            {w,w,w,w}%
        }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
        \printmatrix{42}{{
            {w,b,w,w},
            {b,w,b,w},
            {w,w,w,w},
            {w,w,w,w}%
        }}
    \end{minipage}

\end{center}

Über den gesamten Prozess hinweg wird auch die geschützte Diagonale mitverfolgt,
bei den 3er-Rominos ist sie wie folgt plaziert:

\begin{center}

    \begin{minipage}{0.18\textwidth}
        \printmatrix{273}{{
            {b,w,w,w},
            {w,C,d,w},
            {w,d,C,w},
            {w,w,w,w}%
        }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
        \printmatrix{49}{{
            {C,d,w,w},
            {d,C,b,w},
            {w,w,w,w},
            {w,w,w,w}%
        }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
        \printmatrix{42}{{
            {w,C,d,w},
            {b,d,C,w},
            {w,w,w,w},
            {w,w,w,w}%
        }}
    \end{minipage}

\end{center}

\section{Umsetzung}

Zur Umsetzung haben wir den obigen Algorithmus in C\# 8.0 mit
.NET Core 3.0 implementiert.

Die Rominos werden in Form eines readonly structs \textit{Romino} gespeichert.
Das struct beinhaltet

\begin{enumerate}
    \item \textit{Vector2Int[] Blocks} - 
        Das Array mit allen Blöcken des Rominos.
    \item \textit{List<Vector2Int> PossibleExtensions} - 
        Die Liste mit allen \\ Block-Additionsmöglichkeiten.
        Hierbei ist zu bemerken, dass die Größe der Liste konstant bleibt;
        es wird hier eine Liste statt einem Array verwendet, da bei der
        Erstellung die Größe unbekannt ist, und die Liste noch in ein Array
        zu konvertieren unnötig Rechenzeit kostet.
    \item \textit{Vector2Int DiagonalRoot} - Die linke obere Ecke der 
        geschützten Diagonale.
    \item \textit{Vector2Int Max} - Die rechte untere Ecke des Rominos.
        Verwendet für korrigieren der Verschiebung ohne über alle Blöcke zu
        iterieren.
    \item \textit{BitBuffer512 \_uniqueCode} - Der eindeutige Wert, errechnet
        wie in \ref{uniqueCode}.
\end{enumerate}

Die Hauptmethode ist die statische Methode\\
\textit{IEnumerable<(int Size, List<Romino> Rominos)> Romino.GetRominosUntilSize(int size)}
welche für eine gegebene Größe alle Rominos aller Größen, bis zu dieser
Größe ausgibt. Diese ruft intern parallelisiert für alle Rominos aus einer
Generation die Methode \textit{IEnumerable<Romino> Romino.AddOneNotUnique()}
auf.
Diese Methode errechnet nach dem Verfahren aus \ref{addBlocks} die
Rominos der nächsten Generation.
Danach werden nach dem Verfahren aus \ref{dupl} die Duplikate entfernt.

Die eindeutigen Werte aus \ref{uniqueCode} werden hierbei berechnet, ohne
dass der Romino modifiziert wird, alle Modifikationen die an dem Romino
gemacht werden müssten, um den Wert einer Permutation zu bestimmen, werden
beim orientieren direkt in der Ausrechnung angewendet, ohne das Romino zu
modifizieren. Erst wenn die eindeutige Rotation nach \ref{dupl} gefunden
wurde, wird das Romino so modifiziert, dass es als diese Permutation
dargestellt wird.

\section{Quellcode}



\end{document}