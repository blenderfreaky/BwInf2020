\documentclass[a4paper,10pt,ngerman]{scrartcl}
\usepackage{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[a4paper,margin=2.5cm,footskip=0.5cm]{geometry}

% Die nächsten drei Felder bitte anpassen:
\newcommand{\Aufgabe}{Aufgabe 5: Rominos} % Aufgabennummer und Aufgabennamen angeben
\newcommand{\TeamID}{00587}       % Team-ID aus dem PMS angeben
\newcommand{\TeamName}{Doge.NET} % Team-Namen angeben
\newcommand{\Namen}{Nikolas Kilian \& Johannes von Stoephasius} % Namen der Bearbeiter/-innen dieser Aufgabe angeben

% Fonts
\usepackage{lmodern}
\usepackage{inconsolata}
%\usepackage{courier}

% Kopf- und Fußzeilen
\usepackage{scrlayer-scrpage, lastpage}
\setkomafont{pageheadfoot}{\large\textrm}
\lohead{\Aufgabe}
\rohead{Team-ID: \TeamID}
\cfoot*{\thepage{}/\pageref{LastPage}}

% Position des Titels
\usepackage{titling}
\setlength{\droptitle}{-1.0cm}

% Für mathematische Befehle und Symbole
\usepackage{amsmath}
\usepackage{amssymb}

% Für Bilder
\usepackage{graphicx}

% Für Algorithmen
\usepackage{algpseudocode}

% Für Quelltext
\usepackage{listings}
\usepackage{xcolor}

%\setmonofont{Consolas} %to be used with XeLaTeX or LuaLaTeX
\definecolor{bluekeywords}{rgb}{0,0,1}
\definecolor{greencomments}{rgb}{0,0.5,0}
\definecolor{redstrings}{rgb}{0.64,0.08,0.08}
\definecolor{xmlcomments}{rgb}{0.5,0.5,0.5}
\definecolor{types}{rgb}{0.17,0.57,0.68}
\definecolor{background}{rgb}{0.95,0.95,0.95}

\lstdefinelanguage{CSharp}{ % Better C# highlighting
language=[Sharp]C,
backgroundcolor=\color{background},
captionpos=b,
numbers=left, %Nummerierung
numberstyle=\tiny, % kleine Zeilennummern
frame=lrtb,
showspaces=false,
showtabs=false,
breaklines=true,
showstringspaces=false,
breakatwhitespace=true,
escapeinside={(*@}{@*)},
commentstyle=\color{greencomments},
morekeywords={partial, var, value, get, set},
keywordstyle=\color{bluekeywords},
stringstyle=\color{redstrings},
basicstyle=\ttfamily\small,
literate=%
    {Ö}{{\"O}}1
    {Ä}{{\"A}}1
    {Ü}{{\"U}}1
    {ß}{{\ss}}1
    {ü}{{\"u}}1
    {ä}{{\"a}}1
    {ö}{{\"o}}1
    {~}{{\textasciitilde}}1
}

\usepackage{tikz}
\usetikzlibrary{calc}

% Diese beiden Pakete müssen zuletzt geladen werden
\usepackage{hyperref} % Anklickbare Links im Dokument
\usepackage{cleveref}

\lstMakeShortInline[
  language=CSharp,
  columns=fixed,
  basicstyle=\ttfamily
  ,columns=fixed]|

\lstnewenvironment{lstcs}
    {\lstset{
        language=CSharp,
        basicstyle=\ttfamily,
        breaklines=true,
        columns=fullflexible
    }}
{}

% Daten für die Titelseite
\title{\textbf{\Huge\Aufgabe}}
\author{\LARGE Team-ID: \LARGE \TeamID \\\\
	    \LARGE Team-Name: \LARGE \TeamName \\\\
	    \LARGE Bearbeiter dieser Aufgabe: \\ 
	    \LARGE \Namen\\\\}
\date{\LARGE\today}

\newcommand{\cellsize}{0.5}
\newcommand{\circlesize}{0.35}

\newcommand{\printwhitecell}[2][]{\node[draw=gray, semithick, fill=white, minimum width=\cellsize cm, minimum height=\cellsize cm] at #2 {#1};} 
\newcommand{\printblackcell}[1]{\node[draw=gray, semithick, fill=black, minimum width=\cellsize cm, minimum height=\cellsize cm] at #1 {};} 
\newcommand{\printcircle}[1]{\draw[gray, semithick, fill=gray] #1 circle (\circlesize cm/2);} 
\newcommand{\printblackcircle}[1]{\draw[black, semithick, fill=black] #1 circle (\circlesize cm/8);} 
\newcommand{\printwhitecircle}[1]{\draw[white, semithick, fill=white] #1 circle (\circlesize cm/8);}
%\newcommand{\printdots}[1]{\draw[gray, semithick, fill=gray] #1 circle (\circlesize cm/4);} 

\newcommand{\printcell}[2]{%1
    \if#1w%
        \printwhitecell{#2}%
    \else%
        \if#1b%
            \printblackcell{#2}%
        \else%
            \if#1c%
                \printwhitecell{#2}%
                \printcircle{#2}%
            \else%
                \if#1C%
                    \printblackcell{#2}%
                    \printwhitecircle{#2}%
                \else%
                	\if#1d%
                    \printwhitecell{#2}%
                    \printblackcircle{#2}%
                    \else%
                        \if#1D%
                            \printblackcell{#2}%
                            \printcircle{#2}%
                        \else%
                            \printwhitecell[#1]{#2}%
                        \fi%
                    \fi%
                \fi%
            \fi%
        \fi%
    \fi%
}

\newcommand{\printmatrix}[2]{
    \begin{tikzpicture}
    \foreach \line[count=\i] in #2 {
        \foreach \cell[count=\j] in \line {
            \printcell{\cell}{(\j*\cellsize,-\i*\cellsize)}
        }
        \xdef\width{\j}
    }
    \node at ({0.5*(\width+1)*\cellsize}, {(-\i -1)*\cellsize}) {#1};
    \end{tikzpicture}   
}

\newcommand{\romin}[1]{\rlap{\raisebox{-.5ex}{#1}}}

\begin{document}

\maketitle
\tableofcontents


\section{Lösungsidee}

\subsection{Definitionen}

\paragraph{Romino}

Ein Romino ist eine Ansammlung von Blöcken auf einem 2d Integer-Gitter.

\paragraph{Block}

Ein Block ist eine Position auf dem 2d Gitter, die einem Romino angehört.

\paragraph{Blocksadditionsmöglichkeit}

Eine Blocksadditionsmöglichkeit eines Rominos ist eine Position im 2d-Gitter, wo in zukünftigen Schritten ein neuer Block angefügt werden kann.

In den Grafiken als grauer Kreis dargestellt.

\paragraph{(echte) Diagonale}

Die (echte) Diagonale ist die in der Aufgabenstellung beschriebene diagonale Verbindung zweier Blöcke mit zwei fehlenden Blöcken.

\paragraph{Diagonalenblockade}

Die Diagonalenblockade sind die Blöcke, die für das Schützen der echten Diagonale von Blocksadditionsmöglichkeit ausgeschlossen sind.

In den Grafiken als kleine weiße/schwarze Punkte dargestellt.

\subsection{Kernidee}

Rominos mit \(n\) Blöcken können gefunden werden, in dem zu Rominos mit \(n-1\) Blöcken ein Block angefügt wird. Hierbei muss beachtet werden, dass der Rominostein zusammenhängend bleiben muss und dass mindestens eine Diagonale bleiben muss.

Um alle möglichen Rominos mit \(n\) Blöcken zu finden, muss man also alle Rominos mit \(n-1\) Blöcken finden, und für diese alle Rominos die, durch hinzufügen eines weiteren Blocks enstehen können, ermitteln. Dabei wird es Duplikate geben. Eliminiert man diese, hat man alle möglichen n-Rominos eindeutig gefunden.

\subsubsection{Beispiel}

Nehme man beispielsweise das 2er-Romino, kann man zum Finden aller \(3 (= 2 + 1)\) - Rominos wie folgt Blöcke anfügen:

\printmatrix{}{{
    {c,c,c,w},
    {c,b,w,c},
    {c,w,b,c},
    {w,c,c,c}%
}}

Somit ergeben sich folgende 3-Rominos:

\begin{center}

\begin{minipage}{0.18\textwidth}
\printmatrix{}{{
    {b,w,w,w},
    {w,b,w,w},
    {w,w,b,w},
    {w,w,w,w}%
}}
\end{minipage}
\begin{minipage}{0.18\textwidth}
\printmatrix{}{{
    {w,b,w,w},
    {w,b,w,w},
    {w,w,b,w},
    {w,w,w,w}%
}}
\end{minipage}
\begin{minipage}{0.18\textwidth}
\printmatrix{}{{
    {w,w,b,w},
    {w,b,w,w},
    {w,w,b,w},
    {w,w,w,w}%
}}
\end{minipage}
\begin{minipage}{0.18\textwidth}
\printmatrix{}{{
    {w,w,w,w},
    {b,b,w,w},
    {w,w,b,w},
    {w,w,w,w}%
}}
\end{minipage}
\begin{minipage}{0.18\textwidth}
\printmatrix{}{{
    {w,w,w,w},
    {w,b,w,b},
    {w,w,b,w},
    {w,w,w,w}%
}}
\end{minipage}

\begin{minipage}{0.18\textwidth}
\printmatrix{}{{
    {w,w,w,w},
    {w,b,w,w},
    {b,w,b,w},
    {w,w,w,w}%
}}
\end{minipage}
\begin{minipage}{0.18\textwidth}
\printmatrix{}{{
    {w,w,w,w},
    {w,b,w,w},
    {w,w,b,b},
    {w,w,w,w}%
}}
\end{minipage}
\begin{minipage}{0.18\textwidth}
\printmatrix{}{{
    {w,w,w,w},
    {w,b,w,w},
    {w,w,b,w},
    {w,b,w,w}%
}}
\end{minipage}
\begin{minipage}{0.18\textwidth}
\printmatrix{}{{
    {w,w,w,w},
    {w,b,w,w},
    {w,w,b,w},
    {w,w,b,w}%
}}
\end{minipage}
\begin{minipage}{0.18\textwidth}
\printmatrix{}{{
    {w,w,w,w},
    {w,b,w,w},
    {w,w,b,w},
    {w,w,w,b}%
}}
\end{minipage}

\end{center}

Da Rominos mindestens zwei Steine haben müssen, um eine Diagonale zu besitzen, ist der Rominostein mit den wenigsten Blöcken eine 2er Diagonale.
\begin{center}
\printmatrix{Kleinster Rominostein}{{
    {b,w},
    {w,b}%
}}
\end{center}

Um alle \(n\)-Rominos für ein beliebiges \(n\) zu finden, würde man den obigen Algorithmus verwenden, um aus dem 2er-Romino alle 3er-Rominos zu folgern, dann aus diesen alle 4er-Rominos etc., bis man alle \(n\)-Rominos errechnet hat.

\subsection{Hinzufügen von Blöcken} \label{addBlocks}

Bei Rominos werden konstant die Blocksadditionsmöglichkeiten verfolgt, also die Positionen, wo Blöcke angefügt werden können, sodass das Romino zusammenhängend bleibt. 
Hierfür werden die Nachbarn jedes Blocks des Rominos ermittelt, daraufhin werden Duplikate und bereits belegte Blöcke eliminiert.

\subsubsection{Beispiel}

Nehme man beispielsweise wieder das 2er-Romino, würden die Nachbarn aller Blöcke wie folgt ermittelt werden:

\printmatrix{}{{
    {c,c,c,w},
    {c,D,c,w},
    {c,c,D,w},
    {w,w,w,w}%
}}
\printmatrix{}{{
    {c,c,c,w},
    {c,D,c,c},
    {c,c,D,c},
    {w,c,c,c}%
}}

Nach entfernen bereits existierender Blöcke von den Blocksadditionsmöglichkeit ergibt sich:

\printmatrix{}{{
    {c,c,c,w},
    {c,b,c,c},
    {c,c,b,c},
    {w,c,c,c}%
}}

Es lässt sich hier erkennen, dass die Existenz einer echten Diagonale nicht zwingend aufrecht erhalten wird:

\printmatrix{}{{
    {w,w,w,w},
    {w,b,w,w},
    {w,b,b,w},
    {w,w,w,w}%
}}

Um dafür zu sorgen, dass diese echte Diagonale immer existiert, wird eine spezifische Diagonale immer beschützt.
Bei den möglichen Block-Additionen beim 2er-Romino beispielsweise würden hierfür die für die Diagonale relevanten Blöcke aus den Blockadditionsmöglichkeiten entfernt:

\printmatrix{}{{
    {c,c,c,w},
    {c,C,d,c},
    {c,d,C,c},
    {w,c,c,c}%
}}

Diese 4 beschützten Blöcke werden auch bei Spiegelungen, Verschiebungen und Rotationen mitverfolgt, sodass diese eine Diagonale immer besteht:

\printmatrix{}{{
    {w,c,c,c},
    {c,d,C,c},
    {c,C,d,c},
    {c,c,c,w}%
}}

\subsection{Eliminierung von Duplikaten} \label{dupl}

Zur Eliminierung von Duplikaten werden die Rominos zuerst eindeutig orientiert, um Vergleiche zwischen gleichen, aber transformierten Rominos zu erleichtern.

\subsubsection{Verschiebung}

Die Verschiebung wird eliminiert durch Verschiebung des Rominos in die linke obere Ecke des Gitters; also wird der Block mit der geringsten x-Koordinate auf x=0 verschoben, und der Block mit der geringsten y-Koordinate auf y=0.

\subsubsection{Rotation und Spiegelung} \label{uniqueCode}

Um Rotation und Spiegelung eines Rominos zu eliminieren,
werden zuerst all seine Permutationen
(also alle Kombinationen von Rotation und Spiegelung)
ermittelt, denen jeweils ein eindeutiger Wert zugewiesen wird.
Daraufhin wird das Romino mit dem höchsten dieser eindeutigen Werte ausgewählt.
Hierbei ist es egal, ob der niedrigste oder höchste Wert genommen
wird, solange das Ergebnis eindeutig ist.

Zur Bestimmung dieses eindeutigen Werts haben wir einen trivialen Algorithmus
verwendet wie folgt:

\begin{enumerate}
\item Nehme einen Block \(b\) aus der Permutation des Rominos
\item Seien die Koordinaten \((x, y)\) die Koordinaten des Blocks \(b\), wobei die minimale x-Koordinate und die minimale y-Koordinate aus allen Blöcken der Permutation 0 ist.
\item Man weise dem Block \(b\) den Wert \(2^{(y * <\text{Anzahl an Blöcken}>) + x}\) zu.
\item Der Wert der Permutation ist nun die Summe aller Werte aller Blöcke der Permutation.
\end{enumerate}

%TODO

Es wird quasi der Block als Maske für folgende Werte verwendet:

\begin{center}
    \begin{tikzpicture}[scale=\cellsize]
        \draw (0,0) -- (0,3);
        \draw (1,0) -- (1,3);
        \draw (2,0) -- (2,3);
        \draw (3,0) -- (3,3);
        \draw (0,0) -- (3,0);
        \draw (0,1) -- (3,1);
        \draw (0,2) -- (3,2);
        \draw (0,3) -- (3,3);
        \draw (0.5,2.5) node {$2^0$};
        \draw (1.5,2.5) node {$2^1$};
        \draw (2.5,2.5) node {$2^2$};
        \draw (0.5,1.5) node {$2^3$};
        \draw (1.5,1.5) node {$2^4$};
        \draw (2.5,1.5) node {$2^5$};
        \draw (0.5,0.5) node {$2^6$};
        \draw (1.5,0.5) node {$2^7$};
        \draw (2.5,0.5) node {$2^8$};
    \end{tikzpicture}
\end{center}

\subsubsection{Endgültige Duplikat-Eliminierung}

Zum endgültigen Eliminieren der Duplikate werden zuerst alle Rominos wie oben beschrieben orientiert, dann werden die eindeutigen Werte dieser Rominos verglichen, um schnell Gleichheit zu ermitteln.
Durch Verwendung dieser Vergleichsmethode lassen sich schnell Duplikate entfernen.

\newpage

\subsubsection{Beispiel}

\paragraph{Ausgangsromino}

\printmatrix{}{{
    {c,c,c,w},
    {c,C,d,c},
    {c,d,C,c},
    {w,c,c,c}%
}}

\paragraph{Ermittlung möglicher Rominos}

\begin{center}

    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {b,w,w,w},
        {w,b,w,w},
        {w,w,b,w},
        {w,w,w,w}%
    }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {w,b,w,w},
        {w,b,w,w},
        {w,w,b,w},
        {w,w,w,w}%
    }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {w,w,b,w},
        {w,b,w,w},
        {w,w,b,w},
        {w,w,w,w}%
    }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {w,w,w,w},
        {b,b,w,w},
        {w,w,b,w},
        {w,w,w,w}%
    }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {w,w,w,w},
        {w,b,w,b},
        {w,w,b,w},
        {w,w,w,w}%
    }}
    \end{minipage}
    
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {w,w,w,w},
        {w,b,w,w},
        {b,w,b,w},
        {w,w,w,w}%
    }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {w,w,w,w},
        {w,b,w,w},
        {w,w,b,b},
        {w,w,w,w}%
    }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {w,w,w,w},
        {w,b,w,w},
        {w,w,b,w},
        {w,b,w,w}%
    }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {w,w,w,w},
        {w,b,w,w},
        {w,w,b,w},
        {w,w,b,w}%
    }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {w,w,w,w},
        {w,b,w,w},
        {w,w,b,w},
        {w,w,w,b}%
    }}
    \end{minipage}

\end{center}

\paragraph{Eliminierung von Verschiebungen}

\begin{center}

    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {b,w,w,w},
        {w,b,w,w},
        {w,w,b,w},
        {w,w,w,w}%
    }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {b,w,w,w},
        {b,w,w,w},
        {w,b,w,w},
        {w,w,w,w}%
    }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {w,b,w,w},
        {b,w,w,w},
        {w,b,w,w},
        {w,w,w,w}%
    }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {w,w,w,w},
        {b,b,w,w},
        {w,w,b,w},
        {w,w,w,w}%
    }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {w,w,w,w},
        {b,w,b,w},
        {w,b,w,w},
        {w,w,w,w}%
    }}
    \end{minipage}
    
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {w,b,w,w},
        {b,w,b,w},
        {w,w,w,w},
        {w,w,w,w}%
    }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {b,w,w,w},
        {w,b,b,w},
        {w,w,w,w},
        {w,w,w,w}%
    }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {b,w,w,w},
        {w,b,w,w},
        {b,w,w,w},
        {w,w,w,w}%
    }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {b,w,w,w},
        {w,b,w,w},
        {w,b,w,w},
        {w,w,w,w}%
    }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {b,w,w,w},
        {w,b,w,w},
        {w,w,b,w},
        {w,w,w,w}%
    }}
    \end{minipage}

\end{center}

\paragraph{Eliminierung von Rotation und Spiegelung}
\\
Ausgehend von dem Romino;

\begin{center}

    \printmatrix{}{{
        {b,w,w},
        {w,b,w},
        {w,w,b}%
    }}

\end{center}

werden folgende Permutationen festgestellt:

\begin{center}

    \begin{minipage}{0.4\textwidth}
        \center
        \printmatrix{Permutation 1}{{
            {b,w,w},
            {w,b,w},
            {w,w,b}%
        }}
        \vspace{-0.2cm}
        \[Wert_1 = 2^0 + 2^4 + 2^8 = 273\]
    \end{minipage}
    \begin{minipage}{0.4\textwidth}
        \center
        \printmatrix{Permutation 2}{{
            {w,w,b},
            {w,b,w},
            {b,w,w}%
        }}
        \vspace{-0.2cm}
        \[Wert_2 = 2^2 + 2^4 + 2^6 = 84\]
    \end{minipage}

\end{center}

Hierbei ist \(Wert_2 = 84 < 273 = Wert_1\). Da Permutation 1 mit \(Wert_1\)
den höchsten Wert hat, wird Permutation 1 als die eindeutige Rotierung
festgelegt.

Analog auf alle Rominos angewendet ergibt sich:

\begin{center}

    \begin{minipage}{0.18\textwidth}
        \printmatrix{273}{{
            {b,w,w,w},
            {w,b,w,w},
            {w,w,b,w},
            {w,w,w,w}%
        }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
        \printmatrix{49}{{
            {b,w,w,w},
            {w,b,b,w},
            {w,w,w,w},
            {w,w,w,w}%
        }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
        \printmatrix{42}{{
            {w,b,w,w},
            {b,w,b,w},
            {w,w,w,w},
            {w,w,w,w}%
        }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
        \printmatrix{49}{{
            {b,w,w,w},
            {w,b,b,w},
            {w,w,w,w},
            {w,w,w,w}%
        }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
        \printmatrix{42}{{
            {w,b,w,w},
            {b,w,b,w},
            {w,w,w,w},
            {w,w,w,w}%
        }}
    \end{minipage}
    
    \begin{minipage}{0.18\textwidth}
        \printmatrix{42}{{
            {w,b,w,w},
            {b,w,b,w},
            {w,w,w,w},
            {w,w,w,w}%
        }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
        \printmatrix{49}{{
            {b,w,w,w},
            {w,b,b,w},
            {w,w,w,w},
            {w,w,w,w}%
        }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
        \printmatrix{42}{{
            {w,b,w,w},
            {b,w,b,w},
            {w,w,w,w},
            {w,w,w,w}%
        }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
        \printmatrix{49}{{
            {b,w,w,w},
            {w,b,b,w},
            {w,w,w,w},
            {w,w,w,w}%
        }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
        \printmatrix{273}{{
            {b,w,w,w},
            {w,b,w,w},
            {w,w,b,w},
            {w,w,w,w}%
        }}
    \end{minipage}

\end{center}

Nun lassen sich trivialerweise die Duplikate eliminieren:

\begin{center}

    \begin{minipage}{0.18\textwidth}
        \printmatrix{273}{{
            {b,w,w,w},
            {w,b,w,w},
            {w,w,b,w},
            {w,w,w,w}%
        }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
        \printmatrix{49}{{
            {b,w,w,w},
            {w,b,b,w},
            {w,w,w,w},
            {w,w,w,w}%
        }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
        \printmatrix{42}{{
            {w,b,w,w},
            {b,w,b,w},
            {w,w,w,w},
            {w,w,w,w}%
        }}
    \end{minipage}

\end{center}

Über den gesamten Prozess hinweg wird auch die geschützte Diagonale mitverfolgt.
Bei den 3er-Rominos ist sie wie folgt plaziert:

\begin{center}

    \begin{minipage}{0.18\textwidth}
        \printmatrix{273}{{
            {b,w,w,w},
            {w,C,d,w},
            {w,d,C,w},
            {w,w,w,w}%
        }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
        \printmatrix{49}{{
            {C,d,w,w},
            {d,C,b,w},
            {w,w,w,w},
            {w,w,w,w}%
        }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
        \printmatrix{42}{{
            {w,C,d,w},
            {b,d,C,w},
            {w,w,w,w},
            {w,w,w,w}%
        }}
    \end{minipage}

\end{center}

\section{Umsetzung} \label{umsetzung}

Zur Umsetzung haben wir den obigen Algorithmus in C\# 8.0 mit
.NET Core 3.0 implementiert.\\
Die Rominos werden in Instanzen von |readonly struct Romino| gespeichert.
Das |struct| beinhaltet

\begin{enumerate}
    \item |Vector2Int[] Blocks| - 
        das Array mit allen Blöcken des Rominos,
    \item |List<Vector2Int> PossibleExtensions| - 
        die Liste mit allen Block-Additionsmöglichkeiten.
        Hierbei ist zu bemerken, dass die Größe der Liste konstant bleibt; es wird hier eine Liste statt einem Array verwendet, da bei der Erstellung die Größe unbekannt ist, und die Konvertierung zum Array unnötig Rechenzeit kosten würde,
    \item |Vector2Int DiagonalRoot| - die linke obere Ecke der 
        geschützten Diagonale,
    \item |Vector2Int Max| - die rechte untere Ecke des Rominos.
        Verwendet für die Korrektur der Verschiebung ohne über alle Blöcke zu
        iterieren,
    \item |BitBuffer512 _uniqueCode| - der eindeutige Wert, errechnet
        wie in \cref{uniqueCode}.
\end{enumerate}

Die Hauptmethode ist die statische Methode
|IEnumerable<(int Size, List<Romino> Rominos)> Romino.GetRominosUntilSize(int size)|,
welche für eine gegebene Größe alle Rominos aller Größen bis zu dieser
Größe ausgibt. Diese ruft intern parallelisiert für alle Rominos aus einer
Generation die Methode |IEnumerable<Romino> Romino.AddOneNotUnique()|
auf.
Diese Methode errechnet nach dem Verfahren aus \cref{addBlocks} die
Rominos der nächsten Generation.
Danach werden nach dem Verfahren aus \cref{dupl} die Duplikate entfernt.

Die eindeutigen Werte aus \cref{uniqueCode} werden hierbei berechnet, ohne
dass der Romino modifiziert wird. Alle Modifikationen, die an dem Romino
gemacht werden müssten, um den Wert einer Permutation zu bestimmen, werden
beim Orientieren direkt in der Ausrechnung des eindeutigem Werts angewendet, ohne das Romino zu
modifizieren. Erst wenn die eindeutige Rotation nach \cref{dupl} gefunden
wurde, wird das Romino so modifiziert, dass es als diese Permutation
dargestellt wird.

\subsection{Vector2Int}

|readonly struct Vector2Int| ist ein 2-dimensionaler Vector von
|System.Int32|.

\subsection{BitBuffer512}

|struct BitBuffer512| hält 512 Bits an Daten,
wobei die individuellen Bits mit dem Indexer\\
|BitBuffer512[int bitIndex]| gelesen und geschrieben
werden können. Weiterdem überlädt |BitBuffer512|
Vergleichsoperatoren, die 2 Instanzen wie eine 512 stellige
unsignierte Binärzahlen vergleicht.
Das struct wird zum Speichern des eindeutigem Werts aus
\cref{uniqueCode} verwendet, da der größte vorimplementierte
Zahlentypen, |ulong|, bereits mit 8er-Rominos komplett
gefüllt wird. Im Vergleich kann |BitBuffer512|
Rominos von bis zu 22 Blöcken speichern.

\subsection{Romino}

|readonly struct Romino| ist das Her(t)zstück des Codes; es speichert ein Romino ab,
mit den in \cref{umsetzung} benannten Feldern. Dabei ist das gesamte struct
readonly, und auch die Listen/Arrays werden, auch wenn dies nicht explizit
versichert ist, nie modifiziert, nach dem der Konstruktor durchgelaufen ist.
Der Konstruktor orientiert hier das Romino nach dem Verfahren aus \cref{dupl}.

\section{Beispiele}

|--size 10 --stopwatch|

\begin{lstlisting}
    Starting
    2 done - 1
    3 done - 3
    4 done - 17
    5 done - 82
    6 done - 489
    7 done - 2924
    8 done - 18406
    9 done - 116883
    10 done - 753905
    Done 9370ms
\end{lstlisting}

|--size 5 --latex --highlightPossibleExtensions --highlightDiagonalBlockade|
\subsection{Rominos of size 2 (1)}

\begin{center}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {c,c,c,w},
    {c,C,d,c},
    {c,d,C,c},
    {w,c,c,c}%
}}
\end{minipage}
\end{center}

\subsection{Rominos of size 3 (3)}

\begin{center}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,c,c,c,w},
    {c,c,C,d,c},
    {c,b,d,C,c},
    {c,c,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {c,c,c,w,w},
    {c,b,c,c,w},
    {c,c,C,d,c},
    {w,c,d,C,c},
    {w,w,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {c,c,c,w,w},
    {c,C,d,c,c},
    {c,d,C,b,c},
    {w,c,c,c,c}%
}}
\end{minipage}
\end{center}

\subsection{Rominos of size 4 (17)}

\begin{center}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,c,c,c,w,w},
    {c,d,C,c,c,c},
    {c,C,d,b,b,c},
    {c,c,c,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {c,c,c,w,w,w},
    {c,C,d,c,w,w},
    {c,d,C,c,c,c},
    {w,c,c,b,b,c},
    {w,w,c,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,c,c,c,w,w},
    {c,c,b,c,c,w},
    {c,b,c,C,d,c},
    {c,c,c,d,C,c},
    {w,w,w,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {c,c,c,w,w,w},
    {c,b,c,c,w,w},
    {c,c,b,c,c,w},
    {w,c,c,C,d,c},
    {w,w,c,d,C,c},
    {w,w,w,c,c,c}%
}}
\end{minipage}

\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {c,c,c,w,w,w},
    {c,C,d,c,c,c},
    {c,d,C,b,b,c},
    {w,c,c,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,c,c,c,w},
    {c,c,C,d,c},
    {c,b,d,C,c},
    {c,c,b,c,c},
    {w,c,c,c,w}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {c,c,c,w,w,w},
    {c,C,d,c,c,w},
    {c,d,C,b,c,c},
    {w,c,c,c,b,c},
    {w,w,w,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,c,c,c,w},
    {c,c,b,c,w},
    {c,b,C,d,c},
    {c,c,d,C,c},
    {w,w,c,c,c}%
}}
\end{minipage}

\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {c,c,c,c,w},
    {c,b,C,d,c},
    {c,c,d,C,c},
    {w,w,c,b,c},
    {w,w,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,c,c,c,w},
    {c,d,C,c,c},
    {c,C,d,b,c},
    {c,c,c,b,c},
    {w,w,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,w,c,c,c},
    {c,c,c,b,c},
    {c,b,C,d,c},
    {c,c,d,C,c},
    {w,w,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,w,c,c,c},
    {w,c,c,b,c},
    {c,d,C,c,c},
    {c,C,d,b,c},
    {c,c,c,c,c}%
}}
\end{minipage}

\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {c,c,c,c,c},
    {c,C,d,b,c},
    {c,d,C,b,c},
    {w,c,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,c,c,c,c,w},
    {c,d,C,b,c,c},
    {c,C,d,c,b,c},
    {c,c,c,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {c,c,c,w,w},
    {c,C,d,c,c},
    {c,d,C,b,c},
    {w,c,c,b,c},
    {w,w,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {c,c,c,c,c,w},
    {c,b,c,C,d,c},
    {c,c,b,d,C,c},
    {w,c,c,c,c,c}%
}}
\end{minipage}

\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {c,c,c,c,w,w},
    {c,b,C,d,c,c},
    {c,c,d,C,b,c},
    {w,w,c,c,c,c}%
}}
\end{minipage}
\end{center}

\subsection{Rominos of size 5 (82)}

\begin{center}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,c,c,c,w,w,w},
    {c,d,C,c,c,c,w},
    {c,C,d,b,b,c,c},
    {c,c,c,c,c,b,c},
    {w,w,w,w,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,w,c,c,c,w},
    {c,c,c,C,d,c},
    {c,b,b,d,C,c},
    {c,c,c,b,c,c},
    {w,w,c,c,c,w}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {c,c,c,c,c,w,w},
    {c,b,d,C,c,c,c},
    {c,c,C,d,b,b,c},
    {w,c,c,c,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {c,c,c,w,w,w,w},
    {c,C,d,c,w,w,w},
    {c,d,C,c,c,c,w},
    {w,c,c,b,b,c,c},
    {w,w,c,c,c,b,c},
    {w,w,w,w,c,c,c}%
}}
\end{minipage}

\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,c,c,c,w,w},
    {c,c,b,c,c,w},
    {c,b,c,C,d,c},
    {c,c,c,d,C,c},
    {w,w,c,b,c,c},
    {w,w,c,c,c,w}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {c,c,c,w,w,w},
    {c,b,c,c,c,w},
    {c,c,b,b,c,w},
    {w,c,c,C,d,c},
    {w,w,c,d,C,c},
    {w,w,w,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,c,c,c,w,w},
    {c,d,C,c,c,w},
    {c,C,d,b,c,c},
    {c,c,c,b,b,c},
    {w,w,c,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {c,c,c,c,c},
    {c,b,c,b,c},
    {c,d,C,c,c},
    {c,C,d,b,c},
    {c,c,c,c,c}%
}}
\end{minipage}

\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,w,w,c,c,c},
    {c,c,c,d,C,c},
    {c,b,c,C,d,c},
    {c,c,b,c,b,c},
    {w,c,c,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,c,c,c,w,w,w},
    {c,c,b,c,c,c,c},
    {c,b,c,C,d,b,c},
    {c,c,c,d,C,c,c},
    {w,w,w,c,c,c,w}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,w,c,c,c,w,w},
    {c,c,d,C,c,c,c},
    {c,b,C,d,b,b,c},
    {c,c,c,c,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {c,c,c,c,c,w},
    {c,C,d,b,c,w},
    {c,d,C,c,c,c},
    {w,c,c,b,b,c},
    {w,w,c,c,c,c}%
}}
\end{minipage}

\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {c,c,c,c,w,w,w},
    {c,b,C,d,c,w,w},
    {c,c,d,C,c,c,c},
    {w,w,c,c,b,b,c},
    {w,w,w,c,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {c,c,c,c,c,w},
    {c,C,d,b,c,w},
    {c,d,C,b,c,c},
    {w,c,c,c,b,c},
    {w,w,w,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,c,c,c,w},
    {w,c,b,c,c},
    {c,d,C,b,c},
    {c,C,d,b,c},
    {c,c,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {c,c,c,c,w,w},
    {c,b,C,d,c,c},
    {c,c,d,C,b,c},
    {w,w,c,c,b,c},
    {w,w,w,c,c,c}%
}}
\end{minipage}

\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,w,c,c,c,w},
    {c,c,c,b,c,w},
    {c,b,b,C,d,c},
    {c,c,c,d,C,c},
    {w,w,w,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,c,c,c,w,w},
    {c,d,C,c,c,c},
    {c,C,d,b,b,c},
    {c,c,c,c,b,c},
    {w,w,w,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,w,c,c,c,w,w},
    {c,c,c,C,d,c,w},
    {c,b,b,d,C,c,c},
    {c,c,c,c,c,b,c},
    {w,w,w,w,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,c,c,c,w,w,w},
    {c,c,C,d,c,w,w},
    {c,b,d,C,c,c,c},
    {c,c,c,c,b,b,c},
    {w,w,w,c,c,c,c}%
}}
\end{minipage}

\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {c,c,c,w,w,w},
    {c,C,d,c,c,c},
    {c,d,C,c,b,c},
    {w,c,c,b,c,c},
    {w,w,c,c,b,c},
    {w,w,w,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,w,c,c,c},
    {c,c,c,b,c},
    {c,C,d,b,c},
    {c,d,C,b,c},
    {w,c,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,w,c,c,c,w},
    {c,c,d,C,c,w},
    {c,b,C,d,c,c},
    {c,c,c,b,b,c},
    {w,w,c,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,c,c,c,c,w},
    {c,d,C,b,c,c},
    {c,C,d,b,b,c},
    {c,c,c,c,c,c}%
}}
\end{minipage}

\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,w,w,c,c,c},
    {w,w,c,c,b,c},
    {c,c,c,C,d,c},
    {c,b,b,d,C,c},
    {c,c,c,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {c,c,c,w,w,w},
    {c,C,d,c,w,w},
    {c,d,C,c,c,c},
    {w,c,b,b,b,c},
    {w,c,c,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {c,c,c,c,w},
    {c,b,C,d,c},
    {c,c,d,C,c},
    {w,c,b,b,c},
    {w,c,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {c,c,c,c,c,w},
    {c,b,d,C,c,c},
    {c,c,C,d,b,c},
    {w,c,c,c,b,c},
    {w,w,w,c,c,c}%
}}
\end{minipage}

\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,c,c,c,w,w},
    {c,c,b,c,w,w},
    {c,b,C,d,c,c},
    {c,c,d,C,b,c},
    {w,w,c,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {c,c,c,w,w,w},
    {c,b,c,c,c,w},
    {c,c,b,C,d,c},
    {w,c,c,d,C,c},
    {w,w,w,c,b,c},
    {w,w,w,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,c,c,c,w},
    {c,d,C,c,c},
    {c,C,d,b,c},
    {c,c,b,b,c},
    {w,c,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,c,c,c,w,w},
    {c,d,C,c,c,w},
    {c,C,d,b,c,w},
    {c,c,c,b,c,c},
    {w,w,c,c,b,c},
    {w,w,w,c,c,c}%
}}
\end{minipage}

\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,w,c,c,c,w},
    {c,c,c,C,d,c},
    {c,b,c,d,C,c},
    {c,c,b,b,c,c},
    {w,c,c,c,c,w}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,w,c,c,c,w},
    {w,c,d,C,c,w},
    {c,c,C,d,c,c},
    {c,b,c,b,b,c},
    {c,c,c,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,w,c,c,c,w},
    {c,c,d,C,c,c},
    {c,b,C,d,b,c},
    {c,c,c,c,b,c},
    {w,w,w,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {c,c,c,w,w,w},
    {c,C,d,c,w,w},
    {c,d,C,c,c,c},
    {w,c,c,b,b,c},
    {w,w,c,c,b,c},
    {w,w,w,c,c,c}%
}}
\end{minipage}

\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,c,c,c,w,w},
    {c,c,b,c,c,w},
    {c,b,b,C,d,c},
    {c,c,c,d,C,c},
    {w,w,w,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,w,c,c,c,w,w},
    {w,c,c,b,c,c,w},
    {c,c,b,c,C,d,c},
    {c,b,c,c,d,C,c},
    {c,c,c,w,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,c,c,c,c,c,w},
    {c,d,C,b,b,c,c},
    {c,C,d,c,c,b,c},
    {c,c,c,w,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,w,c,c,c,w},
    {w,c,c,b,c,w},
    {c,c,b,C,d,c},
    {c,b,c,d,C,c},
    {c,c,c,c,c,c}%
}}
\end{minipage}

\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {c,c,c,c,c,c,w},
    {c,b,c,c,C,d,c},
    {c,c,b,b,d,C,c},
    {w,c,c,c,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {c,c,c,w,w,w,w},
    {c,b,c,c,w,w,w},
    {c,c,C,d,c,w,w},
    {w,c,d,C,c,c,c},
    {w,w,c,c,b,b,c},
    {w,w,w,c,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,c,c,c,w,w,w},
    {c,c,b,c,c,w,w},
    {c,b,c,C,d,c,w},
    {c,c,c,d,C,c,c},
    {w,w,w,c,c,b,c},
    {w,w,w,w,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,c,c,c,c,w,w},
    {c,d,C,b,c,c,c},
    {c,C,d,c,b,b,c},
    {c,c,c,c,c,c,c}%
}}
\end{minipage}

\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {c,c,c,w,w},
    {c,C,d,c,c},
    {c,d,C,b,c},
    {c,b,c,b,c},
    {c,c,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,c,c,c,w,w},
    {w,c,b,c,w,w},
    {c,d,C,c,c,c},
    {c,C,d,b,b,c},
    {c,c,c,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,c,c,c,c,w,w},
    {c,c,b,b,c,c,w},
    {c,b,c,c,C,d,c},
    {c,c,c,c,d,C,c},
    {w,w,w,w,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,w,c,c,c,w},
    {c,c,c,b,c,w},
    {c,b,b,c,c,w},
    {c,c,c,C,d,c},
    {w,w,c,d,C,c},
    {w,w,w,c,c,c}%
}}
\end{minipage}

\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,w,c,c,c,w},
    {w,c,c,b,c,c},
    {c,d,C,c,b,c},
    {c,C,d,c,b,c},
    {c,c,c,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,c,c,c,c,w},
    {c,c,b,b,c,w},
    {c,b,c,C,d,c},
    {c,c,c,d,C,c},
    {w,w,w,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {c,c,c,w,w,w,w},
    {c,C,d,c,c,c,c},
    {c,d,C,b,b,b,c},
    {w,c,c,c,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {c,c,c,c,c,c},
    {c,C,d,c,b,c},
    {c,d,C,b,b,c},
    {w,c,c,c,c,c}%
}}
\end{minipage}

\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,w,c,c,c,w},
    {c,c,c,b,c,w},
    {c,C,d,b,c,c},
    {c,d,C,c,b,c},
    {w,c,c,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {c,c,c,w,w,w},
    {c,C,d,c,c,w},
    {c,d,C,b,c,c},
    {w,c,c,b,b,c},
    {w,w,c,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {c,c,c,w,w,w,w},
    {c,C,d,c,c,c,w},
    {c,d,C,c,b,c,c},
    {w,c,c,b,c,b,c},
    {w,w,c,c,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {c,c,c,w,w,w,w},
    {c,C,d,c,c,c,w},
    {c,d,C,b,b,c,c},
    {w,c,c,c,c,b,c},
    {w,w,w,w,c,c,c}%
}}
\end{minipage}

\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {c,c,c,c,c,w},
    {c,b,b,C,d,c},
    {c,c,c,d,C,c},
    {w,w,w,c,b,c},
    {w,w,w,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,c,c,c,c,w},
    {c,d,C,b,c,c},
    {c,C,d,c,b,c},
    {c,c,c,c,b,c},
    {w,w,w,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {c,c,c,c,w,w},
    {c,b,b,c,c,w},
    {c,c,c,C,d,c},
    {w,w,c,d,C,c},
    {w,w,w,c,b,c},
    {w,w,w,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,c,c,c,w,w},
    {c,c,b,c,c,w},
    {c,b,c,C,d,c},
    {c,c,b,d,C,c},
    {w,c,c,c,c,c}%
}}
\end{minipage}

\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,w,c,c,c,w},
    {w,c,c,b,c,w},
    {c,c,b,c,c,w},
    {c,b,c,C,d,c},
    {c,c,c,d,C,c},
    {w,w,w,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,c,c,c,w,w},
    {c,c,b,c,w,w},
    {c,C,d,c,c,c},
    {c,d,C,b,b,c},
    {w,c,c,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {c,c,c,w,w,w,w},
    {c,C,d,c,w,w,w},
    {c,d,C,c,c,c,c},
    {w,c,c,b,b,b,c},
    {w,w,c,c,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {c,c,c,w,w,w},
    {c,C,d,c,c,c},
    {c,d,C,c,b,c},
    {w,c,c,b,b,c},
    {w,w,c,c,c,c}%
}}
\end{minipage}

\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,c,c,c,w,w},
    {c,c,b,c,w,w},
    {c,b,b,c,c,w},
    {c,c,c,C,d,c},
    {w,w,c,d,C,c},
    {w,w,w,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,c,c,c,w,w},
    {c,c,C,d,c,w},
    {c,b,d,C,c,c},
    {c,c,c,c,b,c},
    {w,w,w,c,b,c},
    {w,w,w,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {c,c,c,w,w,w},
    {c,C,d,c,c,c},
    {c,d,C,b,b,c},
    {w,c,c,c,b,c},
    {w,w,w,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,w,w,c,c,c},
    {c,c,c,d,C,c},
    {c,b,b,C,d,c},
    {c,c,c,c,b,c},
    {w,w,w,c,c,c}%
}}
\end{minipage}

\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {c,c,c,w,w,w,w},
    {c,C,d,c,c,w,w},
    {c,d,C,b,c,c,c},
    {w,c,c,c,b,b,c},
    {w,w,w,c,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,c,c,c,c,c,w},
    {c,c,b,c,C,d,c},
    {c,b,c,b,d,C,c},
    {c,c,c,c,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,c,c,c,w,w},
    {c,d,C,c,c,c},
    {c,C,d,b,b,c},
    {c,c,c,b,c,c},
    {w,w,c,c,c,w}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {c,c,c,w,w,w,w},
    {c,b,c,c,w,w,w},
    {c,c,b,c,c,w,w},
    {w,c,c,b,c,c,w},
    {w,w,c,c,C,d,c},
    {w,w,w,c,d,C,c},
    {w,w,w,w,c,c,c}%
}}
\end{minipage}

\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {c,c,c,c,w,w,w},
    {c,b,C,d,c,c,c},
    {c,c,d,C,b,b,c},
    {w,w,c,c,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {c,c,c,c,c,c},
    {c,b,C,d,b,c},
    {c,c,d,C,b,c},
    {w,w,c,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,c,c,c,w,w,w},
    {c,d,C,c,c,c,c},
    {c,C,d,b,b,b,c},
    {c,c,c,c,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,c,c,c,c,c},
    {c,d,C,c,b,c},
    {c,C,d,b,b,c},
    {c,c,c,c,c,c}%
}}
\end{minipage}

\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {c,c,c,c,c,w},
    {c,C,d,b,c,c},
    {c,d,C,b,b,c},
    {w,c,c,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,w,w,c,c,c},
    {w,c,c,c,b,c},
    {c,d,C,b,c,c},
    {c,C,d,c,b,c},
    {c,c,c,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {c,c,c,w,w},
    {c,C,d,c,c},
    {c,d,C,b,c},
    {w,c,b,b,c},
    {w,c,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {c,c,c,c,w,w},
    {c,b,C,d,c,w},
    {c,c,d,C,c,c},
    {w,w,c,b,b,c},
    {w,w,c,c,c,c}%
}}
\end{minipage}

\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,c,c,c,w},
    {c,d,C,c,c},
    {c,C,d,b,c},
    {c,b,c,b,c},
    {c,c,c,c,c}%
}}
\end{minipage}
\begin{minipage}{0.23\textwidth}
\printmatrix{}{{
    {w,w,c,c,c},
    {w,c,c,b,c},
    {c,d,C,b,c},
    {c,C,d,b,c},
    {c,c,c,c,c}%
}}
\end{minipage}
\end{center}

\section{Quellcode}

\begin{lstcs}
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

public readonly struct Romino : IEquatable<Romino>, IComparable<Romino>
{
    /// <summary>
    /// <para>
    /// All different combinations of rotating and mirroring an arbitrary romino.
    /// </para>
    /// <para>
    /// BlockMap represents the functor mapping a block coordinate from the origin romino
    ///   to the rotated/mirrored romino.
    /// </para>
    /// <para>
    /// DiagonalRootMap represents the functor mapping the DiagonalRoot from the origin romino
    ///   to the rotated/mirrored romino.
    ///   Different from BlockMap because the DiagonalRoot is always the upper left of a square
    ///   of 4 coords; 
    /// </para>
    /// <para>    e.g. when mirroring along the y-Axis (x => (-x.X, x.Y)):
    /// 
    ///     Before  After
    ///       |       |
    ///       |       |
    /// </para>
    /// </summary>
    private static readonly (Func<Vector2Int, Vector2Int> BlockMap, Func<Vector2Int, Vector2Int> DiagonalRootMap)[] Maps = new (Func<Vector2Int, Vector2Int> BlockMap, Func<Vector2Int, Vector2Int> DiagonalRootMap)[]
    {
        (x => new Vector2Int(+x.X, +x.Y), x => new Vector2Int(+x.X, +x.Y)),
        (x => new Vector2Int(+x.X, -x.Y), x => new Vector2Int(+x.X, ~x.Y)),
        (x => new Vector2Int(-x.X, +x.Y), x => new Vector2Int(~x.X, +x.Y)),
        (x => new Vector2Int(-x.X, -x.Y), x => new Vector2Int(~x.X, ~x.Y)),
        (x => new Vector2Int(+x.Y, +x.X), x => new Vector2Int(+x.Y, +x.X)),
        (x => new Vector2Int(+x.Y, -x.X), x => new Vector2Int(+x.Y, ~x.X)),
        (x => new Vector2Int(-x.Y, +x.X), x => new Vector2Int(~x.Y, +x.X)),
        (x => new Vector2Int(-x.Y, -x.X), x => new Vector2Int(~x.Y, ~x.X)),
    };

    /// <summary>
    /// The smallest Romino possible
    /// </summary>
    public static Romino One =
        new Romino(blocks: new[] { new Vector2Int(0, 0), new Vector2Int(1, 1) },
            possibleExtensions:
            // These are hardcoded in by hand, because this list is only populated lazily by appending, rather than computed once.
            // As this first romino can not be computed like other rominos, this won't be populated using normal methods.
            new[] { new Vector2Int(-1, -1), new Vector2Int(0, -1), new Vector2Int(1, -1),
                    new Vector2Int(-1, 0),                                                new Vector2Int(2, 0),
                    new Vector2Int(-1, 1),                                                new Vector2Int(2, 1),
                                            new Vector2Int(0, 2),  new Vector2Int(1, 2),  new Vector2Int(2, 2), }
                .ToList(),
            diagonalRoot: new Vector2Int(0, 0),
            max: new Vector2Int(1, 1));

    /// <summary>
    /// All the Blocks composing the Romino.
    /// </summary>
    public readonly Vector2Int[] Blocks;

    /// <summary>
    /// All possible positions for adding new blocks.
    /// </summary>
    /// <remarks>
    /// This is a list, yet the length is fixed.
    /// Reason for this is, that at the point of creation, the size of this is not known,
    /// and converting to an array after the size is known adds unnecessary overhead.
    /// </remarks>
    public readonly List<Vector2Int> PossibleExtensions;

    /// <summary>
    /// The upper left (lowest x, y) corner of the protected diagonal.
    /// </summary>
    public readonly Vector2Int DiagonalRoot;

    /// <summary>
    /// The highest x and y coordinates of any block inside the romino.
    /// </summary>
    public readonly Vector2Int Max;

    /// <summary>
    /// The unique code assigned to this romino.
    /// </summary>
    private readonly BitBuffer512 _uniqueCode;

    /// <summary>
    /// Gets all the blocks blocked by the protected diagonal.
    /// </summary>
    public readonly IEnumerable<Vector2Int> DiagonalRootBlockade
    {
        get
        {
            yield return DiagonalRoot + new Vector2Int(0, 0);
            yield return DiagonalRoot + new Vector2Int(0, 1);
            yield return DiagonalRoot + new Vector2Int(1, 0);
            yield return DiagonalRoot + new Vector2Int(1, 1);
        }
    }

    /// <summary>
    /// Initializes and orients a new instance of the <see cref="Romino"/> structure.
    /// </summary>
    /// <param name="blocks">All the Blocks composing the Romino.</param>
    /// <param name="possibleExtensions">All possible positions for adding new blocks.</param>
    /// <param name="diagonalRoot">The upper left (lowest x, y) corner of the protected diagonal.</param>
    /// <param name="max">The highest x and y coordinates of any block inside the romino.</param>
    public Romino(Vector2Int[] blocks, List<Vector2Int> possibleExtensions, Vector2Int diagonalRoot, Vector2Int max)
    {
        Blocks = blocks;
        DiagonalRoot = diagonalRoot;
        PossibleExtensions = possibleExtensions;
        Max = max;

        _uniqueCode = default; // Needs to be assigned in order to call methods, including CalculateUniqueCode.
        _uniqueCode = CalculateUniqueCode();

        // Find highest unique Code.
        // Start of with asserting the current permutation to be the one with the highest unique code.
        int maxIndex = 0;
        BitBuffer512 maxCode = _uniqueCode;

        // Check against all other permutations, skipping 1, as thats already been calculated.
        for (int i = 1; i < Maps.Length; i++)
        {
            var uniqueCode = CalculateUniqueCode(Maps[i].BlockMap);
            if (maxCode < uniqueCode)
            {
                maxIndex = i;
                maxCode = uniqueCode;
            }
        }

        // Only make changes if the highest unique Code isn't the initial state
        // (Maps[0] = (x => x, x => x))
        if (maxIndex != 0)
        {
            (Func<Vector2Int, Vector2Int> blockMap, Func<Vector2Int, Vector2Int> diagonalRootMap) = Maps[maxIndex];

            var offset = CalculateOffset(blockMap);

            for (int i = 0; i < Blocks.Length; i++) Blocks[i] = blockMap(Blocks[i]) + offset;
            for (int i = 0; i < PossibleExtensions.Count; i++) PossibleExtensions[i] = blockMap(PossibleExtensions[i]) + offset;

            DiagonalRoot = diagonalRootMap(DiagonalRoot) + offset;

            // Don't add offset to max, it might end up with x or y equal to 0.
            var mappedMax = blockMap(Max);
            // Take the absolute of both components, we only care about swapping of x and y, not inversion.
            Max = new Vector2Int(Math.Abs(mappedMax.X), Math.Abs(mappedMax.Y));

            // Recalculate the unique code, as the currently saved one is for Maps[0].
            _uniqueCode = CalculateUniqueCode();
        }
    }

    public static IEnumerable<(int Size, List<Romino> Rominos)> GetRominosUntilSize(int size)
    {
        // Validate arguments outside of iterator block, to prevent the exception being thrown lazily.
        if (size < 2) throw new ArgumentOutOfRangeException(nameof(size));

        return GetRominosUntilSizeInternal();

        IEnumerable<(int Size, List<Romino> Rominos)> GetRominosUntilSizeInternal()
        {
            // Start out with the smalles romino
            List<Romino> lastRominos = new List<Romino> { One };

            // The size of the smallest Romino is 2 blocks; yield it as such.
            yield return (2, lastRominos);

            for (int i = 3; i <= size; i++)
            {
                var newRominos = lastRominos
                    // Enable parallelization using PLINQ.
                    .AsParallel()
                    // Map every romino to all rominos generated by adding one block to it.
                    .SelectMany(x => x.AddOneNotUnique())
                    // Remove duplicates, rominos are already oriented here.
                    .Distinct()
                    // Execute Query by iterating into a list. Cheaper than .ToArray()
                    .ToList();

                // We don't need last generations rominos anymore. Replace them with the new generation.
                lastRominos = newRominos;
                // Yield this generations rominos with their size.
                yield return (i, newRominos);
            }
        }
    }

    // Generate IEnumerable<T> instead of allocing a new array
    /// <summary>
    /// Gets all direct neighbours of a given block, not including the block itself.
    /// </summary>
    /// <param name="block">The block to get the neighbours of</param>
    /// <returns>An <see cref="IEnumerable{Vector2Int}"/> yielding all neighbours</returns>
    private static IEnumerable<Vector2Int> GetDirectNeighbours(Vector2Int block)
    {
        yield return block + new Vector2Int(0, -1);
        yield return block + new Vector2Int(0, 1);
        yield return block + new Vector2Int(1, 0);
        yield return block + new Vector2Int(1, -1);
        yield return block + new Vector2Int(1, 1);
        yield return block + new Vector2Int(-1, 0);
        yield return block + new Vector2Int(-1, -1);
        yield return block + new Vector2Int(-1, 1);
    }

    /// <summary>
    /// Returns all rominos generated by adding one block from <see cref="PossibleExtensions"/>
    /// </summary>
    /// <remarks>Does not remove duplicates, but orients results.</remarks>
    /// <returns>All, non-unique rominos generated by adding one block from <see cref="PossibleExtensions"/>.</returns>
    public readonly IEnumerable<Romino> AddOneNotUnique()
    {
        foreach (var newBlock in PossibleExtensions)
        {
            // If the new block has x or y smaller than 0, move the entire romino such that
            // the lowest x and y are 0.
            // This offset will need to be applied to anything inside the romino.
            var offset = new Vector2Int(Math.Max(-newBlock.X, 0), Math.Max(-newBlock.Y, 0));

            // If the new block is outside of the old rominos bounds, i.e. has bigger x or y coords than Max,
            // increase size.
            var newSize = new Vector2Int(Math.Max(newBlock.X, Max.X), Math.Max(newBlock.Y, Max.Y))
                // or if the new block has coordinates x or y smaller than 0, increase size.
                + offset;

            HashSet<Vector2Int> newPossibleExtensions =
                // Get the direct neighbours, i.e. the blocks that will be possible spots
                // for adding blocks after newBlock has been added
                new HashSet<Vector2Int>(GetDirectNeighbours(newBlock + offset));

            // Remove already occupied positions
            newPossibleExtensions.ExceptWith(Blocks.Select(x => x + offset));
            // Exclude positions blocked by the protected diagonal
            newPossibleExtensions.ExceptWith(DiagonalRootBlockade.Select(x => x + offset));

            // Re-use old extension spots.
            newPossibleExtensions.UnionWith(PossibleExtensions.Select(x => x + offset));

            // Remove the newly added block.
            newPossibleExtensions.Remove(newBlock + offset);

            // Allocate a new array for the new romino, with one more space then right now
            // to store the new block in.
            Vector2Int[] newBlocks = new Vector2Int[Blocks.Length + 1];

            for (int i = 0; i < Blocks.Length; i++)
            {
                // Copy elements from current romino and apply offset.
                newBlocks[i] = Blocks[i] + offset;
            }

            // Insert the new block, also, with offset.
            newBlocks[Blocks.Length] = newBlock + offset;

            yield return new Romino(
                newBlocks,
                new List<Vector2Int>(newPossibleExtensions),
                // Apply offset to the diagonal root as well.
                DiagonalRoot + offset,
                newSize);
        }
    }

    private readonly BitBuffer512 CalculateUniqueCode()
    { /* CalculateUniqueCode(x => x) with the parameter inlined */ }

    private readonly BitBuffer512 CalculateUniqueCode(Func<Vector2Int, Vector2Int> func)
    {
        var bits = new BitBuffer512();

        // "Definitely very useful caching"
        int length = Blocks.Length;

        // Calculate the offset to be applied.
        var offset = CalculateOffset(func);

        for (int i = 0; i < Blocks.Length; i++)
        {
            // Map the block and apply the offset.
            var mapped = func(Blocks[i]) + offset;

            // Assign the relevant bit (2^((y * len) + x) = 1 << ((y * len) + x))
            bits[(mapped.Y * length) + mapped.X] = true;
        }

        return bits;
    }

    /// <summary>
    /// Calculates the offset by which blocks inside the romino need to be moved after applying a given function
    /// in order to still have the lowest x and y be equal to 0.
    /// </summary>
    /// <remarks>The function <paramref name="map"/> may not apply any translations, only 
    /// scaling and rotation around the origin (0, 0) is handled.</remarks>
    /// <param name="map">The function to calculate the offset for.</param>
    /// <returns>The offset that needs to be applied to set the minimum x and y coordinates after applying <paramref name="map"/> back to 0.</returns>
    private readonly Vector2Int CalculateOffset(Func<Vector2Int, Vector2Int> map)
    {
        var mappedSize = map(Max);
        // We only need to offset if the blocks are being moved into the negative,
        // as translations from map are forbidden, and such the min will only change by
        // mirroring around an axis or rotating.
        return new Vector2Int(Math.Max(-mappedSize.X, 0), Math.Max(-mappedSize.Y, 0));
    }

    /// <remarks>Returns invalid results for comparisons between rominos of different sizes</remarks>
    public override readonly bool Equals(object obj) => obj is Romino romino && Equals(romino);

    public override readonly int GetHashCode() => _uniqueCode.GetHashCode();

    /// <remarks>Returns invalid results for comparisons between rominos of different sizes</remarks>
    public readonly bool Equals(Romino romino) => _uniqueCode == romino._uniqueCode;

    /// <remarks>Returns invalid results for comparisons between rominos of different sizes</remarks>
    public readonly int CompareTo(Romino other) => _uniqueCode.CompareTo(other._uniqueCode);
}
\end{lstcs}

\end{document}