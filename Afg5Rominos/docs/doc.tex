\documentclass[12pt]{article}

\usepackage[margin=2.5cm]{geometry}

\usepackage[ngerman]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage{inconsolata}

\usepackage{xcolor}
\usepackage{listings}
\usepackage{courier}

%\setmonofont{Consolas} %to be used with XeLaTeX or LuaLaTeX
\definecolor{bluekeywords}{rgb}{0,0,1}
\definecolor{greencomments}{rgb}{0,0.5,0}
\definecolor{redstrings}{rgb}{0.64,0.08,0.08}
\definecolor{xmlcomments}{rgb}{0.5,0.5,0.5}
\definecolor{types}{rgb}{0.17,0.57,0.68}
\definecolor{background}{rgb}{0.95,0.95,0.95}

\usepackage{listings}
\lstset{language=[Sharp]C,
backgroundcolor=\color{background},
captionpos=b,
numbers=left, %Nummerierung
numberstyle=\tiny, % kleine Zeilennummern
frame=lrtb,
showspaces=false,
showtabs=false,
breaklines=true,
showstringspaces=false,
breakatwhitespace=true,
escapeinside={(*@}{@*)},
commentstyle=\color{greencomments},
morekeywords={partial, var, value, get, set},
keywordstyle=\color{bluekeywords},
stringstyle=\color{redstrings},
basicstyle=\ttfamily\small,
extendedchars=true,
literate=%
    {Ö}{{\"O}}1
    {Ä}{{\"A}}1
    {Ü}{{\"U}}1
    {ß}{{\ss}}1
    {ü}{{\"u}}1
    {ä}{{\"a}}1
    {ö}{{\"o}}1
    {~}{{\textasciitilde}}1
}

\usepackage{amsmath}

\usepackage{tikz}
\usetikzlibrary{calc}

\newcommand{\cellsize}{0.5}
\newcommand{\circlesize}{0.35}

\newcommand{\printwhitecell}[2][]{\node[draw=gray, semithick, fill=white, minimum width=\cellsize cm, minimum height=\cellsize cm] at #2 {#1};} 
\newcommand{\printblackcell}[1]{\node[draw=gray, semithick, fill=black, minimum width=\cellsize cm, minimum height=\cellsize cm] at #1 {};} 
\newcommand{\printcircle}[1]{\draw[gray, semithick, fill=gray] #1 circle (\circlesize cm/2);} 
\newcommand{\printblackcircle}[1]{\draw[black, semithick, fill=black] #1 circle (\circlesize cm/8);} 
\newcommand{\printwhitecircle}[1]{\draw[white, semithick, fill=white] #1 circle (\circlesize cm/8);}
%\newcommand{\printdots}[1]{\draw[gray, semithick, fill=gray] #1 circle (\circlesize cm/4);} 

\newcommand{\printcell}[2]{%1
    \if#1w%
        \printwhitecell{#2}%
    \else%
        \if#1b%
            \printblackcell{#2}%
        \else%
            \if#1c%
                \printwhitecell{#2}%
                \printcircle{#2}%
            \else%
                \if#1C%
                    \printblackcell{#2}%
                    \printwhitecircle{#2}%
                \else
                	\if#1d%
                    \printwhitecell{#2}%
                    \printblackcircle{#2}%
                    \else%
                    \printwhitecell[#1]{#2}%
                    \fi%
                \fi%
            \fi%
        \fi%
    \fi%
}

\newcommand{\printmatrix}[2]{
    \begin{tikzpicture}
    \foreach \line[count=\i] in #2 {
        \foreach \cell[count=\j] in \line {
            \printcell{\cell}{(\j*\cellsize,-\i*\cellsize)}
        }
        \xdef\width{\j}
    }
    \node at ({0.5*(\width+1)*\cellsize}, {(-\i -1)*\cellsize}) {#1};
    \end{tikzpicture}   
}

\begin{document}

\title{Aufgabe 5 - Rominos}

\section{Lösungsidee}

\subsection{Kernidee}

Rominos mitt n Blöcken können gefunden werden, in dem zu Rominos mit (n-1) Blöcken ein Block angefügt wird. Hierbei  muss beachtet werden das der Rominostein zusammenhängend bleiben muss, und dass mindestens eine Diagonale bleiben muss.

Um alle möglichen Rominos mit n Blöcken zu finden, muss man also alle Rominos mit (n-1) Blöcken finden, und für diese alle Rominos die durch hinzufügen eines weiteren Blocks enstehen können ermitteln. Dabei wird es Duplikate geben. Eliminiert man diese hat man alle möglichen n-Rominos eindeutig gefunden.

\subsubsection{Beispiel}

Nehme man beispielsweise das 2er-Romino, kann man zum finden aller 3 (= 2 + 1) - Rominos wie folgt Blöcke anfügen:

\printmatrix{}{{
    {c,c,c,w},
    {c,b,w,c},
    {c,w,b,c},
    {w,c,c,c}%
}}

Somit ergeben sich folgende 3-Rominos:

\begin{center}

\begin{minipage}{0.18\textwidth}
\printmatrix{}{{
    {b,w,w,w},
    {w,b,w,w},
    {w,w,b,w},
    {w,w,w,w}%
}}
\end{minipage}
\begin{minipage}{0.18\textwidth}
\printmatrix{}{{
    {w,b,w,w},
    {w,b,w,w},
    {w,w,b,w},
    {w,w,w,w}%
}}
\end{minipage}
\begin{minipage}{0.18\textwidth}
\printmatrix{}{{
    {w,w,b,w},
    {w,b,w,w},
    {w,w,b,w},
    {w,w,w,w}%
}}
\end{minipage}
\begin{minipage}{0.18\textwidth}
\printmatrix{}{{
    {w,w,w,w},
    {b,b,w,w},
    {w,w,b,w},
    {w,w,w,w}%
}}
\end{minipage}
\begin{minipage}{0.18\textwidth}
\printmatrix{}{{
    {w,w,w,w},
    {w,b,w,b},
    {w,w,b,w},
    {w,w,w,w}%
}}
\end{minipage}

\begin{minipage}{0.18\textwidth}
\printmatrix{}{{
    {w,w,w,w},
    {w,b,w,w},
    {b,w,b,w},
    {w,w,w,w}%
}}
\end{minipage}
\begin{minipage}{0.18\textwidth}
\printmatrix{}{{
    {w,w,w,w},
    {w,b,w,w},
    {w,w,b,b},
    {w,w,w,w}%
}}
\end{minipage}
\begin{minipage}{0.18\textwidth}
\printmatrix{}{{
    {w,w,w,w},
    {w,b,w,w},
    {w,w,b,w},
    {w,b,w,w}%
}}
\end{minipage}
\begin{minipage}{0.18\textwidth}
\printmatrix{}{{
    {w,w,w,w},
    {w,b,w,w},
    {w,w,b,w},
    {w,w,b,w}%
}}
\end{minipage}
\begin{minipage}{0.18\textwidth}
\printmatrix{}{{
    {w,w,w,w},
    {w,b,w,w},
    {w,w,b,w},
    {w,w,w,b}%
}}
\end{minipage}

\end{center}

\newpage

Da Rominos mindestens zwei Steine haben müssen um eine Diagonale zu besitzen, ist der Rominostein mit den wenigsten Blöcken eine 2er Diagonale.
\begin{center}
\printmatrix{Kleinster Rominostein}{{
    {b,w},
    {w,b}%
}}
\end{center}

Um alle n-Rominos für ein beliebiges n zu finden, würde man den obigen Algorithmus verwenden um aus dem 2er-Romino alle 3-Rominos zu folgern, dann aus diesen alle 4-Rominos etc. bis man alle n-Rominos errechnet hat.

\subsection{Hinzufügen von Blöcken} \label{addBlocks}

Um Blöcke hinzuzufügen, werden zuerst die Stellen ermittelt, wo Blöcke angefügt werden können, sodass das Romino zusammenhängend bleibt. Hierfür werden die Nachbarn jedes Blocks des Rominos ermittelt, daraufhin werden Duplikate und bereits belegte Blöcke eliminiert.

\subsubsection{Beispiel}

Nehme man beispielsweise wieder das 2er-Romino, würden die Nachbarn aller Blöcke wie folgt ermittelt werden:

\printmatrix{}{{
    {c,c,c,w},
    {c,C,c,w},
    {c,c,C,w},
    {w,w,w,w}%
}}
\printmatrix{}{{
    {c,c,c,w},
    {c,C,c,c},
    {c,c,C,c},
    {w,c,c,c}%
}}

Entfernen bereits existierender Blöcke

\printmatrix{}{{
    {c,c,c,w},
    {c,b,c,c},
    {c,c,b,c},
    {w,c,c,c}%
}}

Es lässt sich hier erkennen, das die Existenz einer echten Diagonale nicht zwingend aufrecht erhalten wird;

\printmatrix{}{{
    {w,w,w,w},
    {w,b,w,w},
    {w,b,b,w},
    {w,w,w,w}%
}}

Um dafür zu sorgen, dass diese echte Diagonale immer existiert, wird eine spezifische Diagonale immer beschützt. 
Bei den Möglichen Block-Additionen beim 2er-Romino beispielsweise würden hierfür die für die Diagonale relevanten Blöcke aus den Block-Additionsmöglichkeiten entfernt:

\printmatrix{}{{
    {c,c,c,w},
    {c,C,d,c},
    {c,d,C,c},
    {w,c,c,c}%
}}

Diese 4 beschützten Blöcke werden auch bei Spiegelungen, Verschiebungen und Rotationen mitverfolgt, sodass diese eine Diagonale immer besteht.

\subsection{Eliminierung von Duplikaten} \label{dupl}

Zur Eliminierung von Duplikaten werden die Rominos zuerst eindeutig orientiert, um Vergleiche zwischen gleichen, aber transformierten Rominos zu erleichtern.

\subsubsection{Verschiebung}

Die Verschiebung wird eliminiert durch Verschiebung des Rominos in die linke obere Ecke des Gitters; also wird der Block mit der geringsten x-Koordinate auf x=0 verschoben, und der Block mit der geringsten y-Koordinate auf y=0.

\subsubsection{Rotation und Spiegelung} \label{uniqueCode}

Um Rotation und Spiegelung eines Rominos zu eliminieren,
werden zuerst alle seine Permutationen
(also alle Kombinationen von Rotation und Spiegelung)
ermittelt, und denen wird ein eindeutiger Wert zugewiesen.
Daraufhin wird das Romino mit dem höchsten dieser eindeutigen Werte ausgewählt.
Hierbei ist es eigentlich egal, ob der niedrigste oder höchste Wert genommen
wird, solange das Ergebnis eindeutig ist.

Die Bestimmung dieses eindeutigen Werts haben wir einen trivialen Algorithmus
verwendet wie folgt:

\begin{enumerate}
\item Nehme einen Block b aus der Permutation des Rominos
\item Seien die Koordinaten (x, y) die Koordinaten des Blocks b, wobei die minimale x-Koordinate und die minimale y-Koordinate aus allen Blöcken der Permutation 0 ist.
\item Man weise dem Block b den Wert \(2^{(y * <\text{Anzahl an Blöcken}>) + x}\) zu
\item Addiere die Werte aller Blöcke der Permutation, sei dies der Wert der Permutation
\end{enumerate}

Dabei ist zwar noch viel Raum für Optimierung,
aber dieser Algorithmus ist ausreichend und O(n).

\subsubsection{Endgültige Duplikat-Eliminierung}

Zum endgültigen eliminieren der Duplikate werden zuerst alle Rominos
wie oben beschrieben orientiert, dann werden die eindeutigen Werte dieser
verglichen, um schnell Gleichheit zu ermitteln. Durch Verwendung dieser
Vergleichsmethode lassen sich schnell Duplikate entfernen.

\newpage

\subsubsection{Beispiel}

\paragraph{Ausgangsromino}

\printmatrix{}{{
    {c,c,c,w},
    {c,C,d,c},
    {c,d,C,c},
    {w,c,c,c}%
}}

\paragraph{Nächste Rominos}

\begin{center}

    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {b,w,w,w},
        {w,b,w,w},
        {w,w,b,w},
        {w,w,w,w}%
    }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {w,b,w,w},
        {w,b,w,w},
        {w,w,b,w},
        {w,w,w,w}%
    }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {w,w,b,w},
        {w,b,w,w},
        {w,w,b,w},
        {w,w,w,w}%
    }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {w,w,w,w},
        {b,b,w,w},
        {w,w,b,w},
        {w,w,w,w}%
    }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {w,w,w,w},
        {w,b,w,b},
        {w,w,b,w},
        {w,w,w,w}%
    }}
    \end{minipage}
    
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {w,w,w,w},
        {w,b,w,w},
        {b,w,b,w},
        {w,w,w,w}%
    }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {w,w,w,w},
        {w,b,w,w},
        {w,w,b,b},
        {w,w,w,w}%
    }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {w,w,w,w},
        {w,b,w,w},
        {w,w,b,w},
        {w,b,w,w}%
    }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {w,w,w,w},
        {w,b,w,w},
        {w,w,b,w},
        {w,w,b,w}%
    }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {w,w,w,w},
        {w,b,w,w},
        {w,w,b,w},
        {w,w,w,b}%
    }}
    \end{minipage}

\end{center}

\paragraph{Verschiebung eliminieren}

\begin{center}

    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {b,w,w,w},
        {w,b,w,w},
        {w,w,b,w},
        {w,w,w,w}%
    }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {b,w,w,w},
        {b,w,w,w},
        {w,b,w,w},
        {w,w,w,w}%
    }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {w,b,w,w},
        {b,w,w,w},
        {w,b,w,w},
        {w,w,w,w}%
    }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {w,w,w,w},
        {b,b,w,w},
        {w,w,b,w},
        {w,w,w,w}%
    }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {w,w,w,w},
        {b,w,b,w},
        {w,b,w,w},
        {w,w,w,w}%
    }}
    \end{minipage}
    
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {w,b,w,w},
        {b,w,b,w},
        {w,w,w,w},
        {w,w,w,w}%
    }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {b,w,w,w},
        {w,b,b,w},
        {w,w,w,w},
        {w,w,w,w}%
    }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {b,w,w,w},
        {w,b,w,w},
        {b,w,w,w},
        {w,w,w,w}%
    }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {b,w,w,w},
        {w,b,w,w},
        {w,b,w,w},
        {w,w,w,w}%
    }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
    \printmatrix{}{{
        {b,w,w,w},
        {w,b,w,w},
        {w,w,b,w},
        {w,w,w,w}%
    }}
    \end{minipage}

\end{center}

\paragraph{Rotation und Spiegelung eliminieren}


Ausgehend von dem Romino;

\begin{center}

    \printmatrix{}{{
        {b,w,w},
        {w,b,w},
        {w,w,b}%
    }}

\end{center}

werden folgende Permutationen festgestellt:

\begin{center}

    \begin{minipage}{0.4\textwidth}
        \center
        \printmatrix{Permutation 1}{{
            {b,w,w},
            {w,b,w},
            {w,w,b}%
        }}
        \vspace{-0.2cm}
        \[Wert_1 = 2^0 + 2^4 + 2^8 = 273\]
    \end{minipage}
    \begin{minipage}{0.4\textwidth}
        \center
        \printmatrix{Permutation 2}{{
            {w,w,b},
            {w,b,w},
            {b,w,w}%
        }}
        \vspace{-0.2cm}
        \[Wert_2 = 2^2 + 2^4 + 2^6 = 84\]
    \end{minipage}

\end{center}

Hierbei ist \(Wert_2 = 84 < 273 = Wert_1\). Da Permutation 1 mit \(Wert_1\)
den höchsten Wert hat, wird Permutation 1 als die eindeutige Rotierung
festgelegt.

Analog auf alle Rominos angewendet ergibt sich:

\begin{center}

    \begin{minipage}{0.18\textwidth}
        \printmatrix{273}{{
            {b,w,w,w},
            {w,b,w,w},
            {w,w,b,w},
            {w,w,w,w}%
        }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
        \printmatrix{49}{{
            {b,w,w,w},
            {w,b,b,w},
            {w,w,w,w},
            {w,w,w,w}%
        }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
        \printmatrix{42}{{
            {w,b,w,w},
            {b,w,b,w},
            {w,w,w,w},
            {w,w,w,w}%
        }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
        \printmatrix{49}{{
            {b,w,w,w},
            {w,b,b,w},
            {w,w,w,w},
            {w,w,w,w}%
        }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
        \printmatrix{42}{{
            {w,b,w,w},
            {b,w,b,w},
            {w,w,w,w},
            {w,w,w,w}%
        }}
    \end{minipage}
    
    \begin{minipage}{0.18\textwidth}
        \printmatrix{42}{{
            {w,b,w,w},
            {b,w,b,w},
            {w,w,w,w},
            {w,w,w,w}%
        }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
        \printmatrix{49}{{
            {b,w,w,w},
            {w,b,b,w},
            {w,w,w,w},
            {w,w,w,w}%
        }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
        \printmatrix{42}{{
            {w,b,w,w},
            {b,w,b,w},
            {w,w,w,w},
            {w,w,w,w}%
        }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
        \printmatrix{49}{{
            {b,w,w,w},
            {w,b,b,w},
            {w,w,w,w},
            {w,w,w,w}%
        }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
        \printmatrix{273}{{
            {b,w,w,w},
            {w,b,w,w},
            {w,w,b,w},
            {w,w,w,w}%
        }}
    \end{minipage}

\end{center}

Nun lassen sich trivialerweise die Duplikate eliminieren;

\begin{center}

    \begin{minipage}{0.18\textwidth}
        \printmatrix{273}{{
            {b,w,w,w},
            {w,b,w,w},
            {w,w,b,w},
            {w,w,w,w}%
        }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
        \printmatrix{49}{{
            {b,w,w,w},
            {w,b,b,w},
            {w,w,w,w},
            {w,w,w,w}%
        }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
        \printmatrix{42}{{
            {w,b,w,w},
            {b,w,b,w},
            {w,w,w,w},
            {w,w,w,w}%
        }}
    \end{minipage}

\end{center}

Über den gesamten Prozess hinweg wird auch die geschützte Diagonale mitverfolgt,
bei den 3er-Rominos ist sie wie folgt plaziert:

\begin{center}

    \begin{minipage}{0.18\textwidth}
        \printmatrix{273}{{
            {b,w,w,w},
            {w,C,d,w},
            {w,d,C,w},
            {w,w,w,w}%
        }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
        \printmatrix{49}{{
            {C,d,w,w},
            {d,C,b,w},
            {w,w,w,w},
            {w,w,w,w}%
        }}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
        \printmatrix{42}{{
            {w,C,d,w},
            {b,d,C,w},
            {w,w,w,w},
            {w,w,w,w}%
        }}
    \end{minipage}

\end{center}

\section{Umsetzung} \label{umsetzung}

Zur Umsetzung haben wir den obigen Algorithmus in C\# 8.0 mit
.NET Core 3.0 implementiert.

Die Rominos werden in Form eines readonly structs \textit{Romino} gespeichert.
Das struct beinhaltet

\begin{enumerate}
    \item \textit{Vector2Int[] Blocks} - 
        Das Array mit allen Blöcken des Rominos.
    \item \textit{List<Vector2Int> PossibleExtensions} - 
        Die Liste mit allen \\ Block-Additionsmöglichkeiten.
        Hierbei ist zu bemerken, dass die Größe der Liste konstant bleibt;
        es wird hier eine Liste statt einem Array verwendet, da bei der
        Erstellung die Größe unbekannt ist, und die Liste noch in ein Array
        zu konvertieren unnötig Rechenzeit kostet.
    \item \textit{Vector2Int DiagonalRoot} - Die linke obere Ecke der 
        geschützten Diagonale.
    \item \textit{Vector2Int Max} - Die rechte untere Ecke des Rominos.
        Verwendet für korrigieren der Verschiebung ohne über alle Blöcke zu
        iterieren.
    \item \textit{BitBuffer512 \_uniqueCode} - Der eindeutige Wert, errechnet
        wie in \ref{uniqueCode}.
\end{enumerate}

Die Hauptmethode ist die statische Methode\\
\textit{IEnumerable<(int Size, List<Romino> Rominos)> Romino.GetRominosUntilSize(int size)}
welche für eine gegebene Größe alle Rominos aller Größen, bis zu dieser
Größe ausgibt. Diese ruft intern parallelisiert für alle Rominos aus einer
Generation die Methode \textit{IEnumerable<Romino> Romino.AddOneNotUnique()}
auf.
Diese Methode errechnet nach dem Verfahren aus \ref{addBlocks} die
Rominos der nächsten Generation.
Danach werden nach dem Verfahren aus \ref{dupl} die Duplikate entfernt.

Die eindeutigen Werte aus \ref{uniqueCode} werden hierbei berechnet, ohne
dass der Romino modifiziert wird, alle Modifikationen die an dem Romino
gemacht werden müssten, um den Wert einer Permutation zu bestimmen, werden
beim orientieren direkt in der Ausrechnung angewendet, ohne das Romino zu
modifizieren. Erst wenn die eindeutige Rotation nach \ref{dupl} gefunden
wurde, wird das Romino so modifiziert, dass es als diese Permutation
dargestellt wird.

\section{Quellcode}

\subsection{\textit{readonly struct Vector2Int}}

\textit{Vector2Int} ist ein 2-dimensionaler Vector von
\textit{System.Int32}.

\subsection{\textit{struct BitBuffer512}}

\textit{BitBuffer512} hält 512 bits an Daten,
wobei die individuellen Bits mit dem Indexer
\textit{BitBuffer512[int bitIndex]} gelesen und geschrieben
werden können. Weiterdem überlädt \textit{BitBuffer512}
Vergleichsoperatoren, die 2 Instanzen wie eine 512 stellige
unsignierte Binärzahlen vergleicht.
Das struct wird zum speichern des eindeutigem Werts aus
\ref{uniqueCode} verwendet, da der größte vorimplementierte
Zahlentype, \textit{ulong} bereits mit 8er-Rominos komplett
gefüllt wird. Im Vergleich kann \textit{BitBuffer512}
Rominos von bis zu 22 Blöcken speichern.

\subsection{readonly struct Romino}

\textit{Romino} ist das Hertzstück des Codes; es speichert ein Romino ab,
mit den in \ref{umsetzung} benannten Feldern. Dabei ist das gesamte struct
readonly, und auch die Listen/Arrays werden, auch wenn dies nicht explizit
versichert ist, nie modifiziert, nach dem der Konstruktor durchgelaufen ist.
Der Konstruktor orientiert hier das Romino nach dem Verfahren aus \ref{dupl}.

\begin{lstlisting}
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

public readonly struct Romino : IEquatable<Romino>, IComparable<Romino>
{
    /// <summary>
    /// <para>
    /// All different combinations of rotating and mirroring an arbitrary romino.
    /// </para>
    /// <para>
    /// BlockMap represents the functor mapping a block coordinate from the origin romino
    ///   to the rotated/mirrored romino.
    /// </para>
    /// <para>
    /// DiagonalRootMap represents the functor mapping the DiagonalRoot from the origin romino
    ///   to the rotated/mirrored romino.
    ///   Different from BlockMap because the DiagonalRoot is always the upper left of a square
    ///   of 4 coords; 
    /// </para>
    /// <para>    e.g. when mirroring along the y-Axis (x => (-x.X, x.Y)):
    /// 
    ///     Before  After
    ///       |       |
    ///       |       |
    /// </para>
    /// </summary>
    private static readonly (Func<Vector2Int, Vector2Int> BlockMap, Func<Vector2Int, Vector2Int> DiagonalRootMap)[] Maps = new (Func<Vector2Int, Vector2Int> BlockMap, Func<Vector2Int, Vector2Int> DiagonalRootMap)[]
    {
        (x => new Vector2Int(+x.X, +x.Y), x => new Vector2Int(+x.X, +x.Y)),
        (x => new Vector2Int(+x.X, -x.Y), x => new Vector2Int(+x.X, ~x.Y)),
        (x => new Vector2Int(-x.X, +x.Y), x => new Vector2Int(~x.X, +x.Y)),
        (x => new Vector2Int(-x.X, -x.Y), x => new Vector2Int(~x.X, ~x.Y)),
        (x => new Vector2Int(+x.Y, +x.X), x => new Vector2Int(+x.Y, +x.X)),
        (x => new Vector2Int(+x.Y, -x.X), x => new Vector2Int(+x.Y, ~x.X)),
        (x => new Vector2Int(-x.Y, +x.X), x => new Vector2Int(~x.Y, +x.X)),
        (x => new Vector2Int(-x.Y, -x.X), x => new Vector2Int(~x.Y, ~x.X)),
    };

    /// <summary>
    /// The smallest Romino possible
    /// </summary>
    public static Romino One =
        new Romino(blocks: new[] { new Vector2Int(0, 0), new Vector2Int(1, 1) },
            possibleExtensions:
            // These are hardcoded in by hand, because this list is only populated lazily by appending, rather than computed once.
            // As this first romino can not be computed like other rominos, this won't be populated using normal methods.
            new[] { new Vector2Int(-1, -1), new Vector2Int(0, -1), new Vector2Int(1, -1),
                    new Vector2Int(-1, 0),                                                new Vector2Int(2, 0),
                    new Vector2Int(-1, 1),                                                new Vector2Int(2, 1),
                                            new Vector2Int(0, 2),  new Vector2Int(1, 2),  new Vector2Int(2, 2), }
                .ToList(),
            diagonalRoot: new Vector2Int(0, 0),
            max: new Vector2Int(1, 1));

    /// <summary>
    /// All the Blocks composing the Romino.
    /// </summary>
    public readonly Vector2Int[] Blocks;

    /// <summary>
    /// All possible positions for adding new blocks.
    /// </summary>
    /// <remarks>
    /// This is a list, yet the length is fixed.
    /// Reason for this is, that at the point of creation, the size of this is not known,
    /// and converting to an array after the size is known adds unnecessary overhead.
    /// </remarks>
    public readonly List<Vector2Int> PossibleExtensions;

    /// <summary>
    /// The upper left (lowest x, y) corner of the protected diagonal.
    /// </summary>
    public readonly Vector2Int DiagonalRoot;

    /// <summary>
    /// The highest x and y coordinates of any block inside the romino.
    /// </summary>
    public readonly Vector2Int Max;

    /// <summary>
    /// The unique code assigned to this romino.
    /// </summary>
    private readonly BitBuffer512 _uniqueCode;

    /// <summary>
    /// Gets all the blocks blocked by the protected diagonal.
    /// </summary>
    public readonly IEnumerable<Vector2Int> DiagonalRootBlockade
    {
        get
        {
            yield return DiagonalRoot + new Vector2Int(0, 0);
            yield return DiagonalRoot + new Vector2Int(0, 1);
            yield return DiagonalRoot + new Vector2Int(1, 0);
            yield return DiagonalRoot + new Vector2Int(1, 1);
        }
    }

    /// <summary>
    /// Initializes and orients a new instance of the <see cref="Romino"/> structure.
    /// </summary>
    /// <param name="blocks">All the Blocks composing the Romino.</param>
    /// <param name="possibleExtensions">All possible positions for adding new blocks.</param>
    /// <param name="diagonalRoot">The upper left (lowest x, y) corner of the protected diagonal.</param>
    /// <param name="max">The highest x and y coordinates of any block inside the romino.</param>
    public Romino(Vector2Int[] blocks, List<Vector2Int> possibleExtensions, Vector2Int diagonalRoot, Vector2Int max)
    {
        Blocks = blocks;
        DiagonalRoot = diagonalRoot;
        PossibleExtensions = possibleExtensions;
        Max = max;

        _uniqueCode = default; // Needs to be assigned in order to call methods, including CalculateUniqueCode.
        _uniqueCode = CalculateUniqueCode();

        // Find highest unique Code.
        // Start of with asserting the current permutation to be the one with the highest unique code.
        int maxIndex = 0;
        BitBuffer512 maxCode = _uniqueCode;

        // Check against all other permutations, skipping 1, as thats already been calculated.
        for (int i = 1; i < Maps.Length; i++)
        {
            var uniqueCode = CalculateUniqueCode(Maps[i].BlockMap);
            if (maxCode < uniqueCode)
            {
                maxIndex = i;
                maxCode = uniqueCode;
            }
        }

        // Only make changes if the highest unique Code isn't the initial state
        // (Maps[0] = (x => x, x => x))
        if (maxIndex != 0)
        {
            (Func<Vector2Int, Vector2Int> blockMap, Func<Vector2Int, Vector2Int> diagonalRootMap) = Maps[maxIndex];

            var offset = CalculateOffset(blockMap);

            for (int i = 0; i < Blocks.Length; i++) Blocks[i] = blockMap(Blocks[i]) + offset;
            for (int i = 0; i < PossibleExtensions.Count; i++) PossibleExtensions[i] = blockMap(PossibleExtensions[i]) + offset;

            DiagonalRoot = diagonalRootMap(DiagonalRoot) + offset;

            // Don't add offset to max, it might end up with x or y equal to 0.
            var mappedMax = blockMap(Max);
            // Take the absolute of both components, we only care about swapping of x and y, not inversion.
            Max = new Vector2Int(Math.Abs(mappedMax.X), Math.Abs(mappedMax.Y));

            // Recalculate the unique code, as the currently saved one is for Maps[0].
            _uniqueCode = CalculateUniqueCode();
        }
    }

    public static IEnumerable<(int Size, List<Romino> Rominos)> GetRominosUntilSize(int size)
    {
        // Validate arguments outside of iterator block, to prevent the exception being thrown lazily.
        if (size < 2) throw new ArgumentOutOfRangeException(nameof(size));

        return GetRominosUntilSizeInternal();

        IEnumerable<(int Size, List<Romino> Rominos)> GetRominosUntilSizeInternal()
        {
            // Start out with the smalles romino
            List<Romino> lastRominos = new List<Romino> { One };

            // The size of the smallest Romino is 2 blocks; yield it as such.
            yield return (2, lastRominos);

            for (int i = 3; i <= size; i++)
            {
                var newRominos = lastRominos
                    // Enable parallelization using PLINQ.
                    .AsParallel()
                    // Map every romino to all rominos generated by adding one block to it.
                    .SelectMany(x => x.AddOneNotUnique())
                    // Remove duplicates, rominos are already oriented here.
                    .Distinct()
                    // Execute Query by iterating into a list. Cheaper than .ToArray()
                    .ToList();

                // We don't need last generations rominos anymore. Replace them with the new generation.
                lastRominos = newRominos;
                // Yield this generations rominos with their size.
                yield return (i, newRominos);
            }
        }
    }

    // Generate IEnumerable<T> instead of allocing a new array
    /// <summary>
    /// Gets all direct neighbours of a given block, not including the block itself.
    /// </summary>
    /// <param name="block">The block to get the neighbours of</param>
    /// <returns>An <see cref="IEnumerable{Vector2Int}"/> yielding all neighbours</returns>
    private static IEnumerable<Vector2Int> GetDirectNeighbours(Vector2Int block)
    {
        yield return block + new Vector2Int(0, -1);
        yield return block + new Vector2Int(0, 1);
        yield return block + new Vector2Int(1, 0);
        yield return block + new Vector2Int(1, -1);
        yield return block + new Vector2Int(1, 1);
        yield return block + new Vector2Int(-1, 0);
        yield return block + new Vector2Int(-1, -1);
        yield return block + new Vector2Int(-1, 1);
    }

    /// <summary>
    /// Returns all rominos generated by adding one block from <see cref="PossibleExtensions"/>
    /// </summary>
    /// <remarks>Does not remove duplicates, but orients results.</remarks>
    /// <returns>All, non-unique rominos generated by adding one block from <see cref="PossibleExtensions"/>.</returns>
    public readonly IEnumerable<Romino> AddOneNotUnique()
    {
        foreach (var newBlock in PossibleExtensions)
        {
            // If the new block has x or y smaller than 0, move the entire romino such that
            // the lowest x and y are 0.
            // This offset will need to be applied to anything inside the romino.
            var offset = new Vector2Int(Math.Max(-newBlock.X, 0), Math.Max(-newBlock.Y, 0));

            // If the new block is outside of the old rominos bounds, i.e. has bigger x or y coords than Max,
            // increase size.
            var newSize = new Vector2Int(Math.Max(newBlock.X, Max.X), Math.Max(newBlock.Y, Max.Y))
                // or if the new block has coordinates x or y smaller than 0, increase size.
                + offset;

            HashSet<Vector2Int> newPossibleExtensions =
                // Get the direct neighbours, i.e. the blocks that will be possible spots
                // for adding blocks after newBlock has been added
                new HashSet<Vector2Int>(GetDirectNeighbours(newBlock + offset));

            // Remove already occupied positions
            newPossibleExtensions.ExceptWith(Blocks.Select(x => x + offset));
            // Exclude positions blocked by the protected diagonal
            newPossibleExtensions.ExceptWith(DiagonalRootBlockade.Select(x => x + offset));

            // Re-use old extension spots.
            newPossibleExtensions.UnionWith(PossibleExtensions.Select(x => x + offset));

            // Remove the newly added block.
            newPossibleExtensions.Remove(newBlock + offset);

            // Allocate a new array for the new romino, with one more space then right now
            // to store the new block in.
            Vector2Int[] newBlocks = new Vector2Int[Blocks.Length + 1];

            for (int i = 0; i < Blocks.Length; i++)
            {
                // Copy elements from current romino and apply offset.
                newBlocks[i] = Blocks[i] + offset;
            }

            // Insert the new block, also, with offset.
            newBlocks[Blocks.Length] = newBlock + offset;

            yield return new Romino(
                newBlocks,
                new List<Vector2Int>(newPossibleExtensions),
                // Apply offset to the diagonal root as well.
                DiagonalRoot + offset,
                newSize);
        }
    }

    private readonly BitBuffer512 CalculateUniqueCode()
    { /* CalculateUniqueCode(x => x) with the parameter inlined */ }

    private readonly BitBuffer512 CalculateUniqueCode(Func<Vector2Int, Vector2Int> func)
    {
        var bits = new BitBuffer512();

        // "Definitely very useful caching"
        int length = Blocks.Length;

        // Calculate the offset to be applied.
        var offset = CalculateOffset(func);

        for (int i = 0; i < Blocks.Length; i++)
        {
            // Map the block and apply the offset.
            var mapped = func(Blocks[i]) + offset;

            // Assign the relevant bit (2^((y * len) + x) = 1 << ((y * len) + x))
            bits[(mapped.Y * length) + mapped.X] = true;
        }

        return bits;
    }

    /// <summary>
    /// Calculates the offset by which blocks inside the romino need to be moved after applying a given function
    /// in order to still have the lowest x and y be equal to 0.
    /// </summary>
    /// <remarks>The function <paramref name="map"/> may not apply any translations, only 
    /// scaling and rotation around the origin (0, 0) is handled.</remarks>
    /// <param name="map">The function to calculate the offset for.</param>
    /// <returns>The offset that needs to be applied to set the minimum x and y coordinates after applying <paramref name="map"/> back to 0.</returns>
    private readonly Vector2Int CalculateOffset(Func<Vector2Int, Vector2Int> map)
    {
        var mappedSize = map(Max);
        // We only need to offset if the blocks are being moved into the negative,
        // as translations from map are forbidden, and such the min will only change by
        // mirroring around an axis or rotating.
        return new Vector2Int(Math.Max(-mappedSize.X, 0), Math.Max(-mappedSize.Y, 0));
    }

    /// <remarks>Returns invalid results for comparisons between rominos of different sizes</remarks>
    public override readonly bool Equals(object obj) => obj is Romino romino && Equals(romino);

    public override readonly int GetHashCode() => _uniqueCode.GetHashCode();

    /// <remarks>Returns invalid results for comparisons between rominos of different sizes</remarks>
    public readonly bool Equals(Romino romino) => _uniqueCode == romino._uniqueCode;

    /// <remarks>Returns invalid results for comparisons between rominos of different sizes</remarks>
    public readonly int CompareTo(Romino other) => _uniqueCode.CompareTo(other._uniqueCode);
}
\end{lstlisting}

\end{document}